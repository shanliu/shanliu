<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>shanliu blog</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="lsys.html"><strong aria-hidden="true">1.</strong> lsys</a></li><li class="chapter-item expanded "><a href="rust/SUMMARY.html"><strong aria-hidden="true">2.</strong> RUST笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/base.html"><strong aria-hidden="true">2.1.</strong> 一些概念</a></li><li class="chapter-item expanded "><a href="rust/trait.html"><strong aria-hidden="true">2.2.</strong> Trait</a></li><li class="chapter-item expanded "><a href="rust/mod.html"><strong aria-hidden="true">2.3.</strong> mod</a></li><li class="chapter-item expanded "><a href="rust/async.html"><strong aria-hidden="true">2.4.</strong> async</a></li><li class="chapter-item expanded "><a href="rust/enum.html"><strong aria-hidden="true">2.5.</strong> enum</a></li><li class="chapter-item expanded "><a href="rust/collections.html"><strong aria-hidden="true">2.6.</strong> collections</a></li><li class="chapter-item expanded "><a href="rust/variable.html"><strong aria-hidden="true">2.7.</strong> variable</a></li><li class="chapter-item expanded "><a href="rust/string-less-than-greater-than-number.html"><strong aria-hidden="true">2.8.</strong> string&lt;-&gt;number</a></li><li class="chapter-item expanded "><a href="rust/ownership.html"><strong aria-hidden="true">2.9.</strong> ownership</a></li><li class="chapter-item expanded "><a href="rust/lifetime.html"><strong aria-hidden="true">2.10.</strong> lifetime</a></li><li class="chapter-item expanded "><a href="rust/string.html"><strong aria-hidden="true">2.11.</strong> string</a></li><li class="chapter-item expanded "><a href="rust/c-greater-than-rust.html"><strong aria-hidden="true">2.12.</strong> c&lt;-&gt;rust</a></li><li class="chapter-item expanded "><a href="rust/creat.html"><strong aria-hidden="true">2.13.</strong> creat</a></li><li class="chapter-item expanded "><a href="rust/macro.html"><strong aria-hidden="true">2.14.</strong> macro_rules</a></li><li class="chapter-item expanded "><a href="rust/proc-macro.html"><strong aria-hidden="true">2.15.</strong> proc-macro</a></li></ol></li><li class="chapter-item expanded "><a href="cpp/SUMMARY.html"><strong aria-hidden="true">3.</strong> C&amp;CPP笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cpp/syntax.html"><strong aria-hidden="true">3.1.</strong> 语法</a></li><li class="chapter-item expanded "><a href="cpp/debug.html"><strong aria-hidden="true">3.2.</strong> 调试与错误</a></li><li class="chapter-item expanded "><a href="cpp/stdarg.h.html"><strong aria-hidden="true">3.3.</strong> 不定参数</a></li><li class="chapter-item expanded "><a href="cpp/za-xiang.html"><strong aria-hidden="true">3.4.</strong> 杂项</a></li><li class="chapter-item expanded "><a href="cpp/zi-fu-chuan.html"><strong aria-hidden="true">3.5.</strong> 字符串</a></li><li class="chapter-item expanded "><a href="cpp/socket.html"><strong aria-hidden="true">3.6.</strong> 网络</a></li><li class="chapter-item expanded "><a href="cpp/wen-jian.html"><strong aria-hidden="true">3.7.</strong> 文件</a></li><li class="chapter-item expanded "><a href="cpp/jin-cheng.html"><strong aria-hidden="true">3.8.</strong> 进程</a></li><li class="chapter-item expanded "><a href="cpp/pthread.html"><strong aria-hidden="true">3.9.</strong> 线程</a></li><li class="chapter-item expanded "><a href="cpp/xin-hao.html"><strong aria-hidden="true">3.10.</strong> 信号</a></li><li class="chapter-item expanded "><a href="cpp/guan-dao.html"><strong aria-hidden="true">3.11.</strong> 管道</a></li><li class="chapter-item expanded "><a href="cpp/shi-jian.html"><strong aria-hidden="true">3.12.</strong> 时间</a></li><li class="chapter-item expanded "><a href="cpp/dong-tai-jia-zai-ku.html"><strong aria-hidden="true">3.13.</strong> 动态加载库</a></li><li class="chapter-item expanded "><a href="cpp/chang-yong-suan-fa.html"><strong aria-hidden="true">3.14.</strong> 常用算法</a></li><li class="chapter-item expanded "><a href="cpp/gcchun-bian-hui-bian.html"><strong aria-hidden="true">3.15.</strong> C调用汇编</a></li><li class="chapter-item expanded "><a href="cpp/hui-bian-ji-cun-qi.html"><strong aria-hidden="true">3.16.</strong> 汇编寄存器</a></li><li class="chapter-item expanded "><a href="cpp/hui-bian-chang-yong-zhi-ling.html"><strong aria-hidden="true">3.17.</strong> 汇编常用指令</a></li><li class="chapter-item expanded "><a href="cpp/jin-cheng-du-xie-wen-jian-suo.html"><strong aria-hidden="true">3.18.</strong> 进程读写文件锁</a></li><li class="chapter-item expanded "><a href="cpp/phpzhong-jiyu-atomic-de-zi-xuan-suo-shi-xian.html"><strong aria-hidden="true">3.19.</strong> PHP中基于atomic的自旋锁实现</a></li><li class="chapter-item expanded "><a href="cpp/chang-liang-zi-fu-chuan-pi-liang-ying-she.html"><strong aria-hidden="true">3.20.</strong> PHP中常量字符串批量映射</a></li><li class="chapter-item expanded "><a href="cpp/tcpudpxie-yi-xiang-jie.html"><strong aria-hidden="true">3.21.</strong> TCP/UDP包示例</a></li><li class="chapter-item expanded "><a href="cpp/xi-tong-diao-yong-zhong-ding-yi.html"><strong aria-hidden="true">3.22.</strong> 系统函数重定义</a></li><li class="chapter-item expanded "><a href="cpp/bit-op.html"><strong aria-hidden="true">3.23.</strong> 加减乘除位运算</a></li></ol></li><li class="chapter-item expanded "><a href="other/SUMMARY.html"><strong aria-hidden="true">4.</strong> JS和其他笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="other/react-native.html"><strong aria-hidden="true">4.1.</strong> react-native</a></li><li class="chapter-item expanded "><a href="other/rxjs.html"><strong aria-hidden="true">4.2.</strong> rxjs</a></li><li class="chapter-item expanded "><a href="other/vim.html"><strong aria-hidden="true">4.3.</strong> vim</a></li><li class="chapter-item expanded "><a href="other/css-flex.html"><strong aria-hidden="true">4.4.</strong> css flex</a></li><li class="chapter-item expanded "><a href="other/docker.html"><strong aria-hidden="true">4.5.</strong> docker</a></li><li class="chapter-item expanded "><a href="other/es6.html"><strong aria-hidden="true">4.6.</strong> es6</a></li><li class="chapter-item expanded "><a href="other/react.html"><strong aria-hidden="true">4.7.</strong> react</a></li></ol></li><li class="chapter-item expanded "><a href="php/SUMMARY.html"><strong aria-hidden="true">5.</strong> PHP笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="php/composer.html"><strong aria-hidden="true">5.1.</strong> composer</a></li><li class="chapter-item expanded "><a href="php/ext.html"><strong aria-hidden="true">5.2.</strong> 扩展开发</a></li><li class="chapter-item expanded "><a href="php/php7-feature.html"><strong aria-hidden="true">5.3.</strong> php7一些特性</a></li><li class="chapter-item expanded "><a href="php/sort.html"><strong aria-hidden="true">5.4.</strong> php快速排序</a></li><li class="chapter-item expanded "><a href="php/larvale.html"><strong aria-hidden="true">5.5.</strong> larvale</a></li><li class="chapter-item expanded "><a href="php/re2candbison.html"><strong aria-hidden="true">5.6.</strong> re2c&amp;bison</a></li><li class="chapter-item expanded "><a href="php/rabbitmq.html"><strong aria-hidden="true">5.7.</strong> rabbitmq</a></li><li class="chapter-item expanded "><a href="php/proto.html"><strong aria-hidden="true">5.8.</strong> proto</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">shanliu blog</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shanliu" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lsys"><a class="header" href="#lsys">lsys</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust笔记"><a class="header" href="#rust笔记">RUST笔记</a></h1>
<ul>
<li><a href="rust/base.html">基本概念</a></li>
<li><a href="rust/trait.html">Trait</a></li>
<li><a href="rust/mod.html">mod</a></li>
<li><a href="rust/async.html">async</a></li>
<li><a href="rust/enum.html">enum</a></li>
<li><a href="rust/collections.html">collections</a></li>
<li><a href="rust/variable.html">variable</a></li>
<li><a href="rust/string-less-than-greater-than-number.html">string&lt;-&gt;number</a></li>
<li><a href="rust/ownership.html">ownership</a></li>
<li><a href="rust/lifetime.html">lifetime</a></li>
<li><a href="rust/string.html">string</a></li>
<li><a href="rust/c-greater-than-rust.html">c&lt;-&gt;rust</a></li>
<li><a href="rust/creat.html">creat</a></li>
<li><a href="rust/macro.html">macro_rules</a></li>
<li><a href="rust/proc-macro.html">proc-macro</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一些概念"><a class="header" href="#一些概念">一些概念</a></h1>
<pre><code>泛型 
	不可继承
	可限定:trait
	可泛型实现trait
		泛型实现trait的泛型可带trait限定

生命周期 
  存在生命周期生命跟泛型声明时,生命周期参数放前面
	可继承[子长过父]
	函数带引用参数
		输入必须大于输出
	结构带引用
	'static
		局部生命周期可转为'static 如 Box::leak
	方法参数中&amp;self的生命周期
		不能跟自身相同 否则只能调用一次

方法
	静态方法
		无类型实现无法调用
	对象方法[参数 self||&amp;self||mut self||&amp;mut self ] mut self不能再trait的fn中
		无指定类型实现可调用[可根据self推导]
	Self 为类型自身
	可带泛型
	可带生命周期
		引用参数标识生命周期

trait
	可以继承
	无属性
	可带方法
	使用需实现到类型或泛型
	可带泛型
	可带生命周期
	dyn trait [注意是类型不是trait,所以可以 impl traitname for dyn name]
		可将实现类型转为dyn trait 对象[可非安全转回]
		可给dyn trait 增加方法
	返回分发 Box&lt;dyn triat&gt; 和 impl trait
	操作符也是trait
	内部泛型[内部type]
	
	
struct||enum [实体]
	不可继承
	可带属性
	可带方法
	实现trait
		不可多次和远程实现
		可实现多个
		重名方法调用指定trait
		可判断是否实现某类型
	可带泛型
		内嵌泛型实现两[实体]联合 xx&lt;xx&gt; [一级继承]
	可带生命周期
		字段引用标识生命周期
		泛型+生命周期且字段未使用 PhantomData
	Drop trait 实现
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="约束-trait"><a class="header" href="#约束-trait">约束 Trait</a></h2>
<blockquote>
<p>基本示例</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">trait Atest{
    fn aa0(self);
   // fn aa1(mut self);//错误:trait不可以存在可变实体变量
   // fn aab(mut a: Aa);//错误:trait不可以存在可变实体变量
    fn aa2(&amp;self);
    fn aa3(&amp;mut self);
    //fn st2()-&gt;impl Debug; //错误:impl trait 只能对fn跟实体方法返回 trait 用Box&lt;dyn trait&gt;返回
}
#[derive(Debug)]
enum etest1{
    A(i32),
    B(f64)
}
trait a&lt;T&gt;{

}
trait b&lt;T&gt;:a&lt;T&gt;{//带泛型继承

}
trait  ttest1{
	//方法名不可相同.跟CPP不一样,同名方法要多态用泛型实现
    fn fn1(&amp;self)-&gt;i32;//引用,可多次
    fn fn2(self)-&gt;i32;//只执行一次
}
trait  ttest2:ttest1{//继承
    fn fn3(&amp;self)-&gt;i32{
		//注意: self为引用 &amp;self 为引用的引用
        return 1;
    }
}
impl ttest1 for etest1{
    fn fn1(&amp;self) -&gt; i32 {
        if let etest1::A(x) =*self{//模式匹配得到数据
            return x;
        }
        return 0;
    }
    fn fn2(self) -&gt; i32 {
        return 1;
    }
}
impl etest1{
    fn fn4(){}
}
impl ttest2 for etest1{}//继承实现,增加功能
fn main() {
    let s=etest1::A(1);
    s.fn1();
    s.fn3();
    s.fn2();
    etest1::fn4();
}
</code></pre></pre>
<blockquote>
<p>trait 不的函数不支持返回 impl Trait 类型,用Box&lt;dyn *&gt;返回</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::future::Future;
use std::pin::Pin;
struct Sk&lt;'c&gt;{
    a:&amp;'c str
}
struct Sa{}
trait Ta{
    //trait 的方法不支持 impl 返回
    fn aa&lt;'c&gt;(&amp;self,sss:&amp;'c str)-&gt;Pin&lt;Box&lt;dyn Future&lt;Output=Sk&lt;'c&gt;&gt;+'c&gt;&gt;;
}
impl Ta for Sa{
    fn aa&lt;'c&gt;(&amp;self,sss:&amp;'c str) -&gt;Pin&lt;Box&lt;dyn Future&lt;Output=Sk&lt;'c&gt;&gt;+'c&gt;&gt;{
        let a=Sk{
            a:sss
        };
        Box::pin(async move {a})
    }
}
#[tokio::main]
async fn main()  {
    let sa=Sa{};
    let b=&quot;ddd&quot;.to_string();
    let b=b.as_str();
    let m=sa.aa(b).await.a;
    println!(&quot;{}&quot;,m);
}

</code></pre></pre>
<blockquote>
<p>带限制泛型实现trait</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">trait aa{
    fn out(&amp;self)-&gt;i32{
        return 1;
    }
}
trait tl{}
impl&lt;T:tl&gt; aa for T{}//给实现了tl的trait对象实现aa trait 注意:如果没限制会加到所有类型上

struct dome1{}
impl tl for dome1{}//dome1实现了 tl 所以实现aa

fn main() {
    (dome1{}).out();
}
</code></pre></pre>
<blockquote>
<p>全局泛型实现trait</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">trait aa{
    fn out(&amp;self)-&gt;i32{
        println!(&quot;ddd&quot;);
        return 1;
    }
}
impl&lt;T&gt; aa for T{}//等于给所有类型加了aa trait的out方法
fn main() {
    &quot;aa&quot;.out();
    1.out();
}
</code></pre></pre>
<blockquote>
<p>全局泛型多个相同方法trait实现</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">trait aa{
    fn out(&amp;self)-&gt;i32{
        println!(&quot;ddd&quot;);
        return 1;
    }
}
trait bb{
    fn out(&amp;self)-&gt;i32{
        println!(&quot;ddd&quot;);
        return 1;
    }
}
impl&lt;T&gt; aa for T{}//等于给所有类型加了aa trait的out方法
impl&lt;T&gt; bb for T{}//等于给所有类型加了bb trait的out方法
fn main() {
    bb::out(&amp;&quot;aa&quot;);//多次实现,必须手动指定调用那个trait方法
}
</code></pre></pre>
<blockquote>
<p>全局泛型跟结构实现方法同名</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">trait aa{
    fn out(&amp;self){
        println!(&quot;1&quot;);
    }
}
impl&lt;T&gt; aa for T{}//等于给所有类型加了aa trait的out方法
struct dome1{}
impl dome1{
    fn out(&amp;self){//跟全局泛型有同名out方法,会覆盖全局泛型方法
        println!(&quot;2&quot;);
    }
}
fn main() {
    (dome1{}).out();
    &quot;22&quot;.out();
}
</code></pre></pre>
<blockquote>
<p>dyn trait 对象和结构对象转换</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">struct aa{}
impl aa{
    fn aaa(&amp;self){
        println!(&quot;ddd&quot;);
    }
}
trait bb{}
impl bb for aa{}
fn main() {
    let m=aa{};
    let b= &amp;m as &amp;bb;//转为 dyn trait 对象
    let c:&amp;aa;
    unsafe { c=&amp;*(b as *const dyn bb as *const aa); }//dyn trait对象转为指定类型对象,自行保证类型安全
    c.aaa();//转为指定类型对象后调用该类型方法
}
</code></pre></pre>
<blockquote>
<p>判断是否某类型 &amp;&amp; 泛型直接调用</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{}&quot;,(&amp;&quot;dddd&quot; as &amp;Any).is::&lt;i32&gt;());//判断是否实现某类型
struct Atest{}
struct Atest1{}
println!(&quot;{}&quot;,(&amp;Atest{} as &amp;Any).is::&lt;Atest1&gt;());//判断自定义类型
//注意 : 无法实现判断是否实现某 trait 
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>动态triat对象返回 Box&lt;dyn triat&gt;  [动态分发]</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">trait ttest1{
    fn out(&amp;self);
}
struct test1{}
impl ttest1 for test1{
    fn out(&amp;self){
        println!(&quot;test fn1&quot;);
    }
}
struct test2{}
impl ttest1 for test2{
    fn out(&amp;self){
        println!(&quot;test fn2&quot;);
    }
}
fn out(i:i32)-&gt;Box&lt;dyn ttest1&gt;{//返回动态对象方法 Box&lt;dyn trait&gt;
    if(i&gt;0) {
        return Box::new(test1 {});
    }else{
        return Box::new(test2 {});
    }
}
fn main() {
    let b=out(1);//返回动态对象 可以用any判断是什么对象
    b.out();
    let b=out(0);//返回动态对象
    b.out();
}
</code></pre></pre>
<blockquote>
<p><code>impl trait</code> 对象返回 <code>静态分发,闭包就是其中一个实现</code></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::iter;
use std::vec::IntoIter;
// This is the exact same function, but its return type uses `impl Trait`.
// Look how much simpler it is!
fn combine_vecs(
    v: Vec&lt;i32&gt;,
    u: Vec&lt;i32&gt;,
) -&gt; impl Iterator&lt;Item=i32&gt; {
    v.into_iter().chain(u.into_iter()).cycle()
}

fn main() {
    let v1 = vec![1, 2, 3];
    let v2 = vec![4, 5];
    let mut v3 = combine_vecs(v1, v2);
    assert_eq!(Some(1), v3.next());
    assert_eq!(Some(2), v3.next());
    assert_eq!(Some(3), v3.next());
    assert_eq!(Some(4), v3.next());
    assert_eq!(Some(5), v3.next());
    println!(&quot;all done&quot;);
}
</code></pre></pre>
<blockquote>
<p>通过 trait 实现类型约束</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait typeLimitTrait{}//自定义约束用trait
impl typeLimitTrait for i32 {}//实现某类型
impl typeLimitTrait for f32 {}//现某类型
fn out1&lt;T:typeLimitTrait&gt;(a:T)-&gt;T{//限定泛型
    return a;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>模拟多态</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MT1&lt;Ttest&gt;{
    fn t1(a:Ttest){}
}
struct ST1{}
impl MT1&lt;i32&gt; for ST1{
    fn t1(a:i32){}
}
impl MT1&lt;i8&gt; for ST1{
    fn t1(a:i8){}
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>同类型操作符重载</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    value:i32
}
impl Add for Foo{
    type Output = Self;
    fn add(mut self, rhs: Self) -&gt; Self::Output {
        self.value=self.value+rhs.value;
        self
    }
}
fn main() {
    let mut x = Foo { value: 10 };
    let mut b = Foo { value: 10 };
    let c=x+b;
}
</code></pre></pre>
<blockquote>
<p>不同类型操作符重载和泛型限定</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    value:i32
}
impl Add&lt;i32&gt; for Foo{
    type Output = i32;
    fn add(mut self, rhs: i32) -&gt; Self::Output {
        return self.value+rhs;
    }
}
//注意!!!! 限定 Add&lt;i32,Output=i32&gt; 而不是 Add&lt;i32&gt;
//如果限定为 Add&lt;i32&gt; 则输出为 Add&lt;i32&gt;::Output 而不是 i32 因为 Add&lt;i32&gt;未指定 Output
fn add&lt;T:Add&lt;i32,Output=i32&gt;&gt;(a:T)-&gt;i32{
    let b=a+1;//可以+i32 是因为实现了 Add&lt;i32&gt; 
    // 输出 b 为i32 是因为: 
    // Add&lt;i32,Output=i32&gt; 让输入参数的返回为i32 
    // impl Add&lt;i32&gt; for Foo 的 type Output = i32; // 让a+1 返回为i32
    // 以上都是必须的
    return b;
}
fn main() {
    println!(&quot;{}&quot;,add(Foo { value: 10 }));
    //Foo { value: 10 }+10 返回 i32 是因为 impl Add&lt;i32&gt; for Foo 的 type Output = i32;
    //注意跟 add 函数中的区别
    println!(&quot;{}&quot;,Foo { value: 10 }+10);
}
</code></pre></pre>
<blockquote>
<p>带泛型triat实现</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
//trait 泛型 T1=i8 表示默认泛型
trait Dome1&lt;T,T1=i8&gt;{
    //如果用作泛型限制,OUT1跟OUT2可以指定
    // 不指定,调动完test1 的类型为 Dome1&lt;T,T1=i8&gt;::OUT1
    // 指定 T:Dome1&lt;T,T1=i8,OUT1=i8,OUT2=i16&gt; 调动完test1 的类型为 i8
    type OUT1;//内部泛型,实现时不写在外部
    type OUT2;//注意:使用不能是 OUT2 必须为 Self:: 方式 例如 Self::OUT2
    fn test1(&amp;self,a:T,b:T1)-&gt;Self::OUT1;//Self 表示当前类型
    fn test2(&amp;self,a:T,b:T1)-&gt;Self::OUT2;
}
#[derive(Debug)]
enum MYENUM{
    a=1
}
//全部指定类型trait实现
//指定T=i32,T1=i8实现
impl Dome1&lt;i32,i8&gt; for MYENUM{
    type OUT1=i32;
    type OUT2=i8;
    fn test1(&amp;self,a: i32, b: i8) -&gt; Self::OUT1 {//Self 表示当前类型 即:MYENUM
        return a + b as i32;
    }
    fn test2(&amp;self,a: i32, b: i8) -&gt; Self::OUT2 {
        //&amp;self 表示当前示例引用 可以 . 方式调用
        return a as i8 + b ;
    }
}
#[derive(Debug)]
enum MYENUM1{
    a=1
}
//使用Dome1默认的泛型trait实现
impl Dome1&lt;i32&gt; for MYENUM1{
    type OUT1=i32;
    type OUT2=i8;
    fn test1(&amp;self,a: i32, b: i8) -&gt; Self::OUT1 {
        return a + b as i32;
    }
    fn test2(&amp;self,a: i32, b: i8) -&gt; Self::OUT2 {
        return a as i8 + b ;
    }
}
#[derive(Debug)]
enum MYENUM2{
    a=1
}
//实现时使用泛型方式实现泛型trait在指定类型
impl&lt;T&gt; Dome1&lt;T&gt; for MYENUM2{
    type OUT1 = T;
    type OUT2 = i8;
    fn test1(&amp;self, a: T, b: i8)-&gt;Self::OUT1{
        return a;
    }
    fn test2(&amp;self, a: T, b: i8) -&gt;Self::OUT2 {
        return b;
    }
}
fn test1&lt;T&gt;(a:T)-&gt;i32
    //where方式
    //注意:用作限定时 内部OUT*不是必须写的
    where T:Dome1&lt;i32,i8,OUT1=i32&gt;+Debug{
    return a.test1(1,2);
}
fn main() {
    let a=MYENUM1::a;
    a.test1(1,2);
    let b=MYENUM::a;
    test1(b);
    let c=MYENUM2::a;
    c.test1(1, 2);//泛型自动推导
}
</code></pre></pre>
<blockquote>
<p>指定某泛型类型调用</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">trait Ltrait{
    fn test(&amp;self);
}
impl Ltrait for i8{
    fn test(&amp;self) {
        println!(&quot;i8&quot;);
    }
}
impl Ltrait for i32{
    fn test(&amp;self) {
        println!(&quot;i32&quot;);
    }
}
fn bstest&lt;T:Ltrait&gt;(a:T){
    //限制 a的可传入类型
    a.test();
}
fn main() {
    1i32.test();//调用已被赋值到类型方法
    1i8.test();//调用已被赋值到类型方法
    bstest::&lt;i8&gt;(1);//指定 Ltrait for i8 实现调用
    // 全局泛型实现的指定类型调用
    println!(&quot;{}&quot;,&lt;f32&gt;::from(1.0));//指定数据类型泛型调用
}
</code></pre></pre>
<blockquote>
<p>往dyn trait对象增加方法</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test1(){
    trait Aa{}
    struct Bb{}
    impl Bb{
        fn out(&amp;self){
            println!(&quot;aa&quot;);
        }
    }
    impl Aa for Bb{}
    impl dyn Aa{
        //改动态对象增加方法
        fn out(&amp;self){
            println!(&quot;bb&quot;);
        }
    }
    let b=Bb{};
    b.out();//调动到Bb的out方法
    (&amp;b as &amp;dyn Aa).out();//调用到 dyn Aa的方法
}

#[test]
fn test2(){
    trait Aa{}
    trait Ac{
        fn out(&amp;self);
    }
    struct Bb{}
    impl Aa for Bb{}
    impl Ac for dyn Aa{
        //改动态对象增加triat实现
        //实现Aa的方法存在out方法名时需指定triat调用
        fn out(&amp;self){
            println!(&quot;bb1&quot;);
        }
    }
    let b=Bb{};
    (&amp;b as &amp;dyn Aa).out();
}

#[test]
fn test3(){
    trait Aa{
        fn out(&amp;self);
    }
    trait Ac{
        fn out(&amp;self);
    }
    struct Ba{}
    impl Aa for Ba{
        //实现 trait
        fn out(&amp;self){
            println!(&quot;aa&quot;);
        }
    }
    impl Ac for dyn Aa{
        //动态对象重新实现某方法,需要指定该triat调用
        //跟实现多个triat存在重名方法一致.
        fn out(&amp;self){
            Aa::out(self);
            println!(&quot;bb&quot;);
        }
    }
    let b=(&amp;Ba{} as &amp;dyn Aa);
    Aa::out(b);
    b.out();//等于调用 Aa::out(b);
    Ac::out(b);//修改动态对象的指定方法
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>PhantomData 使用</p>
</blockquote>
<pre><code>fn main() {
    struct Aa&lt;T&gt;{
        a:i32,
        _marker:std::marker::PhantomData&lt;T&gt;
    }
    Aa{
        a: 0,
        _marker:std::marker::PhantomData::default()
    }
    as Aa&lt;i32&gt;;//运行时泛型具体到某类型 PhantomData 类型未知,所以运行时不指定将出错
}
</code></pre>
<blockquote>
<p>通过泛型实现类型一级继承</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">struct Ptype&lt;SUBTYPE&gt;{
    _marker:std::marker::PhantomData&lt;SUBTYPE&gt;
}
impl&lt;SUBTYPE&gt; Ptype&lt;SUBTYPE&gt;{
    fn new()-&gt;Self{
        Ptype{
            _marker:std::marker::PhantomData::default()
        }
    }
}
struct Sub1Type{}
impl Ptype&lt;Sub1Type&gt;{
    fn aa(&amp;self)-&gt;i32{
        return 1;
    }
}
struct Sub2Type{}
impl Ptype&lt;Sub2Type&gt;{
    fn bb(&amp;self)-&gt;i32{
        return 2;
    }
}
fn main() {
    print!(&quot;{}&quot;,(Ptype::new() as Ptype&lt;Sub1Type&gt;).aa());
    print!(&quot;{}&quot;,(Ptype::new() as Ptype&lt;Sub2Type&gt;).bb());
}
#[test]
fn test1(){
    struct A&lt;SUBTYPE&gt;{
        _marker:std::marker::PhantomData&lt;SUBTYPE&gt;
    }
    let t1:A&lt;i32&gt;=A{_marker:Default::default()};#运行时得到类型
}
//struct MYTYPE&lt;SUBTYPE&gt;
// SUBTYPE:LIMIT_TRAIT
//     实现 LIMIT_TRAIT 一批子类型增加方法实现
//     SUBTYPE指定类型实现

</code></pre></pre>
<blockquote>
<p>无指定类型实现trait调用问题</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">trait aaa1{
    fn out(){}
}
trait aaa2{
    fn out(&amp;self){
    }
}
impl&lt;T&gt; aaa1 for T{}
impl&lt;T&gt; aaa2 for T{}
fn main() {
    //aaa1::out(); //cannot infer type
    aaa2::out(&amp;1);//能推导出当前附属到的类型
}
</code></pre></pre>
<blockquote>
<p>复合类型中泛型限定方法增加</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Mlimit{}
//impl&lt;T&gt; Mlimit for T{} //最顶层泛型 全局泛型实现
struct Mytest&lt;T1&gt; {a:T1}
//impl&lt;T1:Mlimit&gt; Mlimit for Mytest&lt;T1&gt; {} //类型实现 trait
//impl&lt;T3&gt; Mytest&lt;T3&gt;{}//类型增加方法
impl&lt;T3:Mlimit&gt; Mytest&lt;T3&gt;//给类型内部泛型限定下增加该类型方法
{
    fn fn1(self) {}
}
impl Mlimit for i32{}
(Mytest{a:1}).fn1();
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>泛型使用时不能做特化处理</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
trait IDB {}
struct IMY1 {}
impl IDB for IMY1 {}
struct IMY2 {}
impl IDB for IMY2 {}
fn bind1&lt;T: IDB&gt;(_: T) {}
struct F1&lt;DB:IDB&gt;{_tmp:DB}
impl &lt;DB:IDB&gt;F1&lt;DB&gt;{
    fn _myexec(_:DB)  {
        //泛型不能特化处理
        //bind1::&lt;DB&gt;(IMY1{});
    }
}
impl F1&lt;IMY1&gt;{
    fn myexec()  {
        bind1(IMY1{});
    }
}
impl F1&lt;IMY2&gt;{
    fn myexec()  {
        bind1(IMY2{});
    }
}
fn main() {
    F1::&lt;IMY1&gt;::myexec();
    F1::&lt;IMY2&gt;::myexec();
}
</code></pre></pre>
<blockquote>
<p>泛型约束示例</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">trait IDB {}
struct IMY{}
impl IDB for IMY{}
trait Encode&lt;DB:IDB&gt; {}
struct Query&lt;DB:IDB&gt;{
    _a:DB
}
impl &lt;DB: IDB&gt; Query&lt;DB&gt; {
    fn bind1&lt;T:Encode&lt;DB&gt; &gt;(&amp;self, _: T)  {}
}
impl Encode&lt;IMY&gt; for i32 {}
fn main() {
    fn myexec&lt;DB:IDB&gt;(pool:DB) 
    where i32:Encode&lt;DB&gt; //加约束实现泛型替换关联
    {
        let res =Query{_a:pool};
        res.bind1(1);
    }
    myexec::&lt;IMY&gt;(IMY{});
}rs
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="模块-mod"><a class="header" href="#模块-mod">模块 mod</a></h2>
<blockquote>
<p>参考文件目录结构:</p>
</blockquote>
<pre><code class="language-bash">/src
/src/dome1
/src/dome1/mod.rs #文件夹mod入口约定文件,在这里包含子mod
/src/dome1/doma.rs #基于文件的mod,在mod.rs引入此文件
/src/domb.rs #基于文件的mod,在mod.rs引入此文件
/src/gdoma.rs #基于文件的mod
/src/lib.rs #当外部mod用,入口约定文件 生成文件名:lib+[包名:package.name]
/src/main.rs #存在此文件会编译可执行文件
</code></pre>
<blockquote>
<p>引入mod和使用</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//引入外部mod
//extern crate bba;
//导入宏,这样导入调用宏时不用写mod名
#[macro_use] extern crate bba;
//引入内部文件夹mod
mod dome1;
//引入内部文件mod
mod gdoma;
//在当前使用其他mod中定义宏,直接用不带mod名
#[macro_use] mod domb;
//使用非本文件[trait fn struct enum等]声明,方法如下:
//use bba::*;//外部库批量声明
use dome1::domep as bbb;//使用别名声明
use std::borrow::{BorrowMut, Borrow};//指定声明

//#[macro_use] 
// 1.用在外部crate时,该crate的下的导出宏不用改crate名使用
// 2.用在内部mod下时,可以直接使用该mod下定义的宏,也是唯一使用子mod下非#[macro_export]宏的方式
// 3.不同crate下 宏必须使用 #[macro_export] 导出,外部才能用
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>宏声明</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//外部crate可用宏 #[macro_export] 等于直接把宏放置于crate根节点
#[macro_export]
macro_rules! test{()=&gt;()}
//宏使用当前包函数等 $crate
pub fn increment(x: u32) -&gt; u32 { x + 1 }
macro_rules! inc {
    ($x:expr) =&gt; ( $crate::increment($x) )
}
<span class="boring">}
</span></code></pre></pre>
<p>单文件多个mod,可见性控制 [/src/gdoma.rs]</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod aaa{
    // trait 整体控制,不可到fn
    pub trait tdome1{//外部可见
        fn t1fn(&amp;self);
    }
    trait tdome2{//外部不可见,对象试下以下方法包外部不可用
        fn t2fn(&amp;self);
    }
    //属性单独控制可见性
    pub struct dome1{//字段 如果有一个非pub 将不可外部实例化
        pub a:i32,
        pub b:i32,
    }
    //方法单独控制可见性
    impl dome1{
        pub fn aaa(&amp;self){//外部可访问
            self.bbb();
        }
        fn bbb(&amp;self){//外部可访问
            self.bbb();
        }
    }
    impl tdome1 for dome1{//实现 pub trait tdome1 方法都外部可见
        fn t1fn(&amp;self) {}
    }
    impl tdome2 for dome1{//实现 pub trait tdome1 方法外部都不可见
        fn t2fn(&amp;self) {}
    }
    pub fn gdoma(){//外部可访问
        println!(&quot;gdoma&quot;);
    }
    pub mod bbb{
        pub fn gdoma(){
            self::gdomb();//self:: 自身mod
        }
        pub fn gdomb(){
            println!(&quot;gdomb&quot;);
        }
        pub mod ccc{
            pub fn gdoma(){
                super::super::gdoma();//super:: 上级mod
            }
        }
    }
    pub mod bbb1{
        pub fn gdoma(){
            crate::gdoma::aaa::gdoma();//crate:: 项目根,非当前文件
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="异步"><a class="header" href="#异步">异步</a></h2>
<h1 id="async"><a class="header" href="#async">async</a></h1>
<blockquote>
<p>执行器过程:</p>
</blockquote>
<ol>
<li>
<p>由IO复用或定时阻塞的<code>轮训循环</code></p>
</li>
<li>
<p>在循环内调用 future 的poll方法[传入触发完成的回调函数的上下文Context]</p>
<pre><code>//`轮训循环` 循环内的伪代码:
let task = Arc::new(Task {});//TASK 必须实现 ArcWake
let waker = waker_ref(&amp;task);
let context = &amp;mut Context::from_waker(&amp;*waker);//传给 poll
future.boxed().as_mut().poll(context);
//同时将waker 挂载到future 属性上
</code></pre>
<pre><code>//完成时从futrue的属性上获取到waker并调用 waker.wake() 后会进入以下函数
impl ArcWake for Task {
 fn wake_by_ref(arc_self: &amp;Arc&lt;Self&gt;) {
     //完成触发后会进入这里
     //这里触发来源:自定义future的poll函数内的回调挂载的:context.waker().clone() 同时挂载到future属性
     //这里触发时,`轮训循环` 一般进入等待状态
     //这里进行某些操作后,`轮训循环`得于继续运行并调用poll
 }
}
</code></pre>
</li>
<li>
<p>全部完成时结束循环</p>
</li>
</ol>
<blockquote>
<p>future 分类</p>
</blockquote>
<ol>
<li>
<p>async 代码转换实现future</p>
<pre><code>let a=async{//跟闭包类似,可以return返回
 let b=async{};
 b.await;
 //遇到 await 时,会调用对应future的poll函数
 //如果函数返回 Pending,会一直返回到 最顶层 `轮训循环`
 //因为自定义的poll函数内不会有 await 语法,
 //所以返回 Pending时可以保证在一直返回到最顶层
 //如果函数返回Ready,继续async块的代码执行
 //二次进入：（resume）时：  
 //先到async块，然后跳转到跳出时的await位置 
 //在根据get_context(cx:ResumeTy) 得到cx并从中获取上次跳出时的 future
 //再次调用该future的poll方法
};
</code></pre>
<pre><code>//async块的转换的 future 是包含生成器(gen) 
//async块的转换的 future poll 一般会多于2次进入
//自定义的future的一般就2次，一次等待一次完成
//async块的转换的 future poll 函数内容如下：
//由生成器的 gen.resume 实现运行由poll的内容到 async{这里的内容} 的跳转运行
//async块的转换的 future poll 本身不会有暂停或阻塞的情况出现
let gen = unsafe { Pin::map_unchecked_mut(self, |s| &amp;mut s.0) };
match gen.resume(ResumeTy(NonNull::from(cx).cast::&lt;Context&lt;'static&gt;&gt;())) {
 GeneratorState::Yielded(()) =&gt; Poll::Pending,//保证返回到`最顶层循环`代码
 GeneratorState::Complete(x) =&gt; Poll::Ready(x),//完成时返回
}
</code></pre>
</li>
<li>
<p>自定义 future 实现 impl Future </p>
<pre><code>impl Future for TimerFuture {
 type Output = ();
 fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
     //自定义future一般只会进入2次
     //第1次
     //如果未完成,返回:Poll::Pending 这里一般是需要暂停或阻塞情况
     //同时挂载回调函数 = Some(cx.waker().clone());//这个挂载可在其他线程或内部一些异步IO库中
     //第2次
     //完成时poll返回:Poll::Ready(())
     //await一定是在async的异步代码中,所以这里不会有await情况
     //除非实现类似async块的转换的 future 的结构(gen)否则不会大于2次进入poll函数
 }
}
</code></pre>
</li>
</ol>
<blockquote>
<p>future的内部转换</p>
</blockquote>
<pre><code>async =&gt; future{
    //异步函数的过程内容转为POLL过程内容，类似闭包
    //局部变量转为属性[有局部变量引用时候存在问题,所以有pin]
    //函数调用转为一个struct[类似闭包转换]挂到属性.
}
//Future转换过程
Future{
    state//状态机,跟踪进度用 跳转到那个await
    a//局部变量转为普通变量
    struct b//内部函数调用转为结构
    Future c//遇到 await 转为Future结构挂载到属性
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;{
       //async 代码转换实现future 内部实现 代码省略
    }
}
</code></pre>
<p>async块Result类型指定返回</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a=async{return Result::&lt;i32,i32&gt;::Ok(2)};//&lt;&gt;操作符
<span class="boring">}
</span></code></pre></pre>
<p>Pin加Unpin实现:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn execute_unpin_future(x: impl Future&lt;Output = ()&gt; + Unpin) {}
let fut = async {};
let fut = Box::pin(fut);//跟使用futrue的boxed方法一样
execute_unpin_future(fut); // OK
let fut = async {};
pin_utils::pin_mut!(fut);//跟上面Box::pin(fut)类似
execute_unpin_future(fut); // OK
//实现了Unpin表示可以安全移动 一般无内部局部变量引用都实现了Unpin 如常用的基本类型

<span class="boring">}
</span></code></pre></pre>
<p>多个async同步</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Book;
struct Music;
async fn get_book() -&gt; Book { Book }
async fn get_music() -&gt; Music { Music }


mod join {
    use super::*;
    use futures::join;
    //两个future完成
    pub(crate) async fn get_book_and_music() -&gt; (Book, Music) {
        let book_fut = get_book();
        let music_fut = get_music();
        join!(book_fut, music_fut)
    }
    #[test]
    fn get_book_and_music_test() {
        futures::executor::block_on(get_book_and_music());
    }
}

mod try_join {
    use super::{Book, Music};
    use futures::try_join;
    //两个future完成,其中一个返回失败立即返回
    async fn get_book() -&gt; Result&lt;Book, String&gt; { /* ... */ Ok(Book) }
    async fn get_music() -&gt; Result&lt;Music, String&gt; { /* ... */ Ok(Music) }
    async fn get_book_and_music() -&gt; Result&lt;(Book, Music), String&gt; {
        let book_fut = get_book();
        let music_fut = get_music();
        try_join!(book_fut, music_fut)
    }
    #[test]
    fn get_book_and_music_test() {
        futures::executor::block_on(get_book_and_music());
    }
}

mod mismatched_err {
    use super::{Book, Music};
    use futures::{
        future::TryFutureExt,
        try_join,
    };
    async fn get_book() -&gt; Result&lt;Book, ()&gt; { /* ... */ Ok(Book) }
    async fn get_music() -&gt; Result&lt;Music, String&gt; { /* ... */ Ok(Music) }
    async fn get_book_and_music() -&gt; Result&lt;(Book, Music), String&gt; {
        let book_fut = get_book().map_err(|()| &quot;Unable to get book&quot;.to_string());
        let music_fut = get_music();
        try_join!(book_fut, music_fut)
    }
    #[test]
    fn get_book_and_music_test() {
        futures::executor::block_on(get_book_and_music());
    }
}

mod example {
    // ANCHOR: example
    use futures::{
        future::FutureExt, // for `.fuse()`
        pin_mut,
        select,
    };
    async fn task_one() { /* ... */ }
    async fn task_two() { /* ... */ }
    //select等待
    async fn race_tasks() {
        let t1 = task_one().fuse();
        let t2 = task_two().fuse();
        pin_mut!(t1, t2);
        select! {
            //返回=future=&gt;操作
            () = t1 =&gt; println!(&quot;task one completed first&quot;),
            () = t2 =&gt; println!(&quot;task two completed first&quot;),
        }
    }
    #[test]
    fn race_tasks_test() {
        futures::executor::block_on(race_tasks());
    }
}

mod default_and_complete {
    use futures::{future, select};
    async fn count() {
        let mut a_fut = future::ready(4);
        let mut b_fut = future::ready(6);
        let mut total = 0;
        loop {
            select! {
                a = a_fut =&gt; total += a,
                b = b_fut =&gt; total += b,
                complete =&gt; break,//全部完成
                //default 在这里不会生效,因为 future::ready 是终止的
                default =&gt; unreachable!(), // future都是未完成且非终止的进这里,需要通过自己的future.await 处理
            };
        }
        assert_eq!(total, 10);
    }
    #[test]
    fn run_count() {
        futures::executor::block_on(count());
    }
}


mod channels {
    use {
        futures::{
            channel::mpsc,
            prelude::*,
        },
    };
    async fn send_recv() {
        const BUFFER_SIZE: usize = 10;
        let (mut tx, mut rx) = mpsc::channel::&lt;i32&gt;(BUFFER_SIZE);
        tx.send(1).await.unwrap();
        tx.send(2).await.unwrap();
        drop(tx);
        assert_eq!(Some(1), rx.next().await);
        assert_eq!(Some(2), rx.next().await);
        assert_eq!(None, rx.next().await);
    }
    #[test]
    fn run_send_recv() { futures::executor::block_on(send_recv()) }
}

<span class="boring">}
</span></code></pre></pre>
<p>多个future 的遍历</p>
<pre><pre class="playground"><code class="language-rust">use async_std::task;

use futures::{
    stream::{Stream, FusedStream},
    select,
    SinkExt,
    StreamExt,
};
use async_std::sync::Arc;
use std::time::Duration;

async fn add_two_streams(
    mut s1: impl Stream&lt;Item = i32&gt; + FusedStream + Unpin,
    mut s2: impl Stream&lt;Item = i32&gt; + FusedStream + Unpin
) -&gt; i32 {
    let mut total = 0;
    loop {//select 将多个future合并成一个,生成方式如下:通过实现 FusedFuture::is_terminated 判断时完成处理future
		//创建合并future的闭包,把上面的多个future放入一个闭包,由闭包内调用future的poll方法
		//在根据是否进行default定义进行以下两种处理
		//1.未指定:default,把闭包通过 futures::future::poll_fn 转为 future 后进行 future.await ,承接到外部运行时
		//2.指定:default,直接调用创建的闭包,如果闭包未返回完成,承接到定义的default里处理
        let item = select! {//遍历future
            x = s1.next() =&gt; x,
            x = s2.next() =&gt; x,
            // default =&gt;{
			//	当`未终止`的所有future`都是`Pending 时这里
			//  当需要`自定义`都未准备完成时的处理时才定义这里
            //  return myfuture{}.await;//例如这里的myfuture.await 这样承接到外部运行时
			//  Some(1) //如果直接返回值,外部用loop循环时会浪费大量CPU.所以一般要定义里面必须会有await
            // },
            complete =&gt; break,//future都完成进这
        };
        println!(&quot;select:{:?}&quot;,item);
        if let Some(next_num) = item {
            total += next_num;
        }
    }
    total
}
fn main() {
    task::block_on(async{
        let  (mut send, mut recv1)= futures::channel::mpsc::channel::&lt;i32&gt;(10);
        send.send(11).await.unwrap();
        send.send(20).await.unwrap();
        drop(send);
        let  (mut send, mut recv2)= futures::channel::mpsc::channel::&lt;i32&gt;(10);
        std::thread::spawn(move ||{
            std::thread::sleep(Duration::from_secs(10));
            task::block_on(async{
                send.send(21).await.unwrap();
                send.send(22).await.unwrap();
                drop(send);
            });
        });
        let t=add_two_streams(recv1,recv2);
        let t1=t.await;
        println!(&quot;{}&quot;,t1);
    });
}
</code></pre></pre>
<p>异步递归调用</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::future::{BoxFuture, FutureExt};
fn recursive(mut a:i32) -&gt; BoxFuture&lt;'static,i32&gt; {
    async move {
        a=a+1;
        if a&lt;100 {
            return  recursive(a).await;
        }
        a
    }.boxed()
}
recursive(1).await;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="枚举-enum"><a class="header" href="#枚举-enum">枚举 enum</a></h2>
<blockquote>
<p>枚举中闭包</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> #[derive(Debug)]
    enum Ta{
        A(i32),//类型:参数为i32,返回自身的闭包 A(i32)-&gt;Ta
        B(i32)//类型:参数为i32,返回自身的闭包
    }
    //实现根据类型得到对应类型变量
    fn aaa&lt;T:Fn(i32)-&gt;Ta&gt;(a:T)-&gt;Ta{
        a(1)
    }
    let k=aaa(Ta::A);
    println!(&quot;{:?}&quot;,k);
    let k=aaa(Ta::B);
    println!(&quot;{:?}&quot;,k);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>enmu 示例</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">enum etest1{
    A,//跟C里面的枚举差不多
    B(f64),//待参数枚举,用于实现多类型变量
    C{a:i32}//结构枚举
}
//enum etest1{
//    A=2,//如果存在()或struct不可以有赋值,这将报错
//    B(f64)
//}
fn main() {
    let tvar1=etest1::A;
    if let etest1::A =tvar1 {//必须模式匹配,不能相等判断
        println!(&quot;match&quot;);
    }
    let tvar1=etest1::C{a:1};//带参数枚举
    if let etest1::C{a} =tvar1{
        println!(&quot;{}&quot;,a);
    }
    let tvar=etest1::B(0.1);//带参数枚举
    //枚举可以通过模式匹配得到枚举里面数据
    if let etest1::B(x) =tvar{
        println!(&quot;{}&quot;,x);
    }
}
</code></pre></pre>
<blockquote>
<p>Option 类型</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b=(Some(1)).and_then(|x|Some('1'));//闭包返回更换OPTION类型,返回OPTION
let b=(Some(1)).and(Some('c'));//直接替换OPTION类型
let b=(Some(1)).map(|x|{'s'});//闭包返回更换OPTION类型,返回数据
let b=(Some(1)).replace(12);//替换掉值
let b=(Some(1)).filter(||true);//闭包返回真使用当前值,否则变为NONE
let b=(Some(1)).or(Some(1));//为NONE是使用指定值
let b=(Some(1)).or_else(||Some(1));//为NONE时闭包返回替换
let b=(Some(1)).ok_or(1);//转为RESULT,不存在时指定数据
let b=(Some(1)).ok_or_else(|x|1);//转为RESULT,不存在时指定闭包返回数据
let b=(Some(1)).take();//返回当前值并用默认值填充
let b=(Some(1)).map_or_else(||1,||2);//根据实际数据闭包返回解包
let b=(Some(1)).map_or(11,|x|{12});//默认值指定,数据根据实际数据闭包返回解包
let b=(Some(1)).expect(&quot;xxxx&quot;);//指定异常消息解包
let b=(Some(1)).unwrap();//按内部异常消息解包
let b=(Some(1)).xor(None);//异或处理 两个一样时候返回NONE
let b=(Some(1)).get_or_insert(1);//判断不存在时候使用指定值插入并解包
let b=(Some(1)).get_or_insert_with(||1);//判断不存在时候使用指定值插入闭包返回并解包
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Result&lt;T,U&gt;类型</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub typeMYResult&lt;T&gt; = Result&lt;T, String&gt;;
    let b=(MYResult::Ok(1)).and_then(|x|MYResult::Ok('1'));//闭包返回更换OPTION类型,返回OPTION
    let b=(MYResult::Ok(1)).and(MYResult::Ok('c'));//直接替换OPTION类型
    let b=(MYResult::Ok(1)).map(|x|{'s'});//闭包返回更换OPTION类型,返回数据
    let b=(MYResult::Ok(1)).or(MYResult::Ok(1));//为NONE是使用指定值
    let b=(MYResult::Ok(1)).or_else(|e|MYResult::Err(&quot;cc&quot;.to_string()));//为NONE时闭包返回替换
    let c=(MYResult::Ok(1)).map_err(|x|&quot;xxxx&quot;);//错误时回调替换
    let b=(Some(1)).filter(|e|true);//闭包返回真使用当前值
    let c=(MYResult::Ok(1)).err();//转为OPTION 正常为NONE错误为Some
    let c=(MYResult::Ok(1)).ok();//转为OPTION,正常为Some 错误为NONE
    let c=(MYResult::Ok(1)).is_err();//是否错误
    let c=(MYResult::Ok(1)).is_ok();//是否正常
    let c=(MYResult::Ok(1)).unwrap_err();//解包:解错误包,正常时异常
    let c=(MYResult::Ok(1)).unwrap();//解包:错误时异常
    let c=(MYResult::Ok(1)).unwrap_or(1);//解包:错误时用指定值代替
    let c=(MYResult::Ok(1)).unwrap_or_default();//解包:错误时用默认值
    let c=(MYResult::Ok(1)).unwrap_or_else(|x|11);//解包:错误时用指定闭包返回替换
    let b=(MYResult::Ok(1)).map_or_else(|e|1,|e|2);//解包:根据实际数据闭包返回解包
    let b=(MYResult::Ok(1)).map_or(11,|x|{12});//解包:默认值指定,数据根据实际数据闭包返回解包
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="集合-collections"><a class="header" href="#集合-collections">集合 [collections]</a></h2>
<pre><pre class="playground"><code class="language-rust">
use std::collections::HashMap;
fn main() {
    let bb=[1,2,3];//数组
    //let t=bb[4];//抛出异常,不建议直接访问
    let mut bbv =Vec::from(bb);
    //查找
    let t=bbv.binary_search(&amp;1);
    if t.is_ok() {
        println!(&quot;{:?}&quot;,t.unwrap());
    }
    //增加
    bbv.insert(0,5);
    bbv.push(11);
    bbv.extend(vec![1,2,3]);//批量加
    //删除
    bbv.pop();
    bbv.remove(bbv.len()-1);
    //获取
    println!(&quot;{:?}&quot;,bbv.get(5));//返回Option
    bbv[1]=111;//注意是否超范围
    println!(&quot;{:?}&quot;,bbv.get(5));//转为vec后可抗访问
    //转为迭代器
    let t=bbv.into_iter();
    //从迭代器还原
    let tt=t.collect::&lt;Vec&lt;i32&gt;&gt;();
    println!(&quot;{:?}&quot;,tt);//转为vec后可抗访问
    
    let mut u=vec![1,2,4];
    //let t=u[10];//下标引用超范围触发panic，跟切片 数组一样，用get处理
    println!(&quot;{:?}&quot;,u);
    let mut u1=&amp;u[0..2];//直接获取切片
    println!(&quot;{:?}&quot;,u1);
    let ss=u.drain(1..3);//获取指定范围迭代器并清理调该数据
    println!(&quot;{:?}&quot;,ss);
    drop(ss);//结束可变引用
    println!(&quot;{:?}&quot;,u);//剩余未被drain数据
    
     let m=String::from_utf8(Vec::from(b&quot;dddddddd&quot; as &amp;[u8])).expect(&quot;dddddd&quot;);
    let o=&amp;m[0..2];//字符串内部由vec[u8]组成
    
    let result = panic::catch_unwind(|| {
        let m=10;
        let s=&amp;u[0..m];//超范围访问捕捉
    });
    println!(&quot;{:?}&quot;,result);
    
    //合并迭代器
    let chaint=vec![1,2].into_iter().chain(vec![2,3,4].into_iter());
    for out in chaint {
        println!(&quot;{}&quot;,out);
    }
    //待索引迭代
    let it=vec![1,2,3].into_iter().enumerate();
    for (a,b) in it {
        println!(&quot;i:{} data:{}&quot;,a,b);
    }
    //转为map迭代器
    let map=vec![1,2,3].into_iter().map(|e|{
       println!(&quot;map:{}&quot;,e);
    });
    map.collect::&lt;Vec&lt;_&gt;&gt;();//MAP迭代器进行迭代

    //附带参数迭代器
    let scan=vec![1,2,3].into_iter().scan(10,|initdata,param|{
        //initdata 提供的附带数据 10
        //param 迭代数据
        if param==1 {
            return Some(param);
        }else{
            return None;//返回0停止迭代
        }
    });
    let out=scan.collect::&lt;Vec&lt;_&gt;&gt;();//scan迭代器进行迭代
    println!(&quot;{:?}&quot;,out);

    //两层vec结构转一层
    let out=vec![vec![1, 2, 3, 4], vec![5, 6]].into_iter().flatten();
    println!(&quot;{:?}&quot;,out.collect::&lt;Vec&lt;_&gt;&gt;());

    //无限循环不退出,用在对结果多次遍历
    let out=vec![1,2,3].into_iter().cycle();
    let mut skip =true;
    for t in out {
        println!(&quot;cycle:{}&quot;,t);
        if t&gt;=3 { skip=false};
        if !skip { break;}
    }
    //以下两个方法配合用于获取指定范围的迭代器
    //skip 跳过指定迭代数量
    //take 进行迭代数量
    let iter = vec![2,2,3,4,5].into_iter().skip(2).take(1);
    for t in iter {
        println!(&quot;take:{}&quot;,t); 
    }

    //出现None后,以后都返回none,在自定义迭代器时用
    let iter =vec![1,1].into_iter().fuse();


    //一个为真返回为真
    let any =vec![1,1].into_iter().any(|x|{return x&gt;0});

    //跟scan类似.函数式累加
    let fold=vec![1,2].into_iter().fold(&quot;dd&quot;.to_string(),|xx,x|{
        return format!(&quot;{}{}&quot;,xx,x);
    });
    println!(&quot;fold:{}&quot;,fold);

    //any collect fold 属于迭代消费器

let a1 = [1, 2, 3];
let a2 = [4, 5, 6];

let mut iter = a1.iter().zip(a2.iter());

assert_eq!(iter.next(), Some((&amp;1, &amp;4)));
assert_eq!(iter.next(), Some((&amp;2, &amp;5)));
assert_eq!(iter.next(), Some((&amp;3, &amp;6)));
assert_eq!(iter.next(), None);


    let mut map = HashMap::new();
    map.insert(&quot;a&quot;, 1);
    map.insert(&quot;b&quot;, 2);
    let iter = map.iter();//迭代器
    for (key,val) in iter {
        println!(&quot;key:{}-val:{}&quot;,key,val);
    }
    println!(&quot;{:?}&quot;,map.keys());//返回KEY
    let iter = map.drain();//清空并创建迭代器 可变借用,迭代前不可访问
    for (key,val) in iter {
        println!(&quot;key:{}-val:{}&quot;,key,val);
    }
    println!(&quot;{:?}&quot;,map);

    //字符串迭代器处理
    let bb=&quot;tt|tt&quot;;
    let cc=&quot;tt1|tt1&quot;;
    let split=bb.split(&quot;|&quot;);
    println!(&quot;{:?}&quot;,split.clone().collect::&lt;Vec&lt;&amp;str&gt;&gt;());
    let chain=split.chain(cc.split(&quot;|&quot;));
    println!(&quot;{:?}&quot;,chain.collect::&lt;Vec&lt;&amp;str&gt;&gt;());

}
</code></pre></pre>
<p>自定义迭代器</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //自定义迭代器实现
    struct aa&lt;i32&gt;{
        data:Vec&lt;i32&gt;,
        iter:usize
    }
    impl Iterator for aa&lt;i32&gt;{
        type Item = i32;
        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
            if self.iter&lt;self.data.len() {
                let t: i32 =self.data[self.iter];
                self.iter+=1;
                return Some(t);
            }else{
                return None;
            }
        }
        //
        fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
             (self.data.len(), None)
             //已明确知道的元素数量，可能的最大元素数量（无法确认none）
             //未迭代的迭代器 已知道元素为0
             //但可能最大元素为总数
         }
    }
    let b=aa{
        data:vec![1,1,2],
        iter:0
    };
    for cc in b {
        println!(&quot;{}&quot;,cc);
    }
}
</code></pre></pre>
<p>迭代时元素增加代替</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a=vec![1,2];//进行迭代时没所有权,不能往vec增加元素
    let mut tmp:Vec&lt;i32&gt;=vec![];//所以使用另一个vec来存储迭代时新增要迭代数据
    // 等于再次迭代这个新增的迭代器里数据来模拟往a里新增效果
    loop{
        let lop;
        if tmp.len()&gt;0 {
            lop=tmp.clone().into_iter();
            tmp.clear();
        }else{
            lop=a.clone().into_iter();
        }
        for core in lop {
            if core&lt;=1 {//符合某些规则时新增迭代数据
                tmp.push(10);//继续往下处理迭代的新增数据
            }
        }
        if tmp.len()==0 {break}
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="变量"><a class="header" href="#变量">变量</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//可以放在代码任何地方,变量不可在最外层
const var1:i32=1;//常量:非固定内存地址,不可改动
static mut a:i32=1;//静态变量:固定内存地址,mut为不安全数据,只赋值一次
let u8=b'z';//u8类型定义
<span class="boring">}
</span></code></pre></pre>
<p>所有权类型仅BOX可以解引用</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b=Box::new(aa{});//非复制类型
let c=*b;//b 不在可用
//默认 Box&lt;T+'static&gt;; 如果T非'static 需主动声明 Box&lt;T+'c&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Deref需返回引用</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Deref for YOUSTRUCT{
    fn deref(&amp;self) -&gt; &amp;YOUSTRUCT {
        &amp;**YOUSTRUCT;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>不可COPY元素数组初始化</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let c:[Option&lt;Box&lt;i32&gt;&gt;;10]=Default::default();//[None;10];
<span class="boring">}
</span></code></pre></pre>
<p>常用函数说明</p>
<blockquote>
<p>borrow|borrow_mut 跟 &amp; | &amp; mut 一致<br />
Option 的as_ref|as_mut 对包内部数据的包裹内引用,基本类型没这方法_<br />
<em>Box 的as_ref|as_mut 为得到内部包数据的引用,基本类型没这方法</em><br />
不可拷贝数据注意所有权问题</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//as_ref as_mut 同外壳的内部引用[Option] 或 直接对壳内的数据引用[Box]
let a=Result::&lt;i32,i32&gt;::Ok(1);
let b=a.as_ref();
let a=Some(1);
let b=a.as_ref();

//borrow borrow_mut 轻量级引用[所有类型都实现] 大部分 等于 等于 &amp;
//某些类型 如 String Box 的 borrow 等于 待壳引用和不带壳引用[取决于返回类型定义] 大于 &amp;
use std::borrow::{Borrow, BorrowMut};
let mut a =Result::&lt;i32,i32&gt;::Ok(1);
let b=a.borrow();
let b=&amp;a;
let a=&amp;Some(1);
let b=a.borrow();
#[derive(Eq, PartialEq)]
struct Aa{};
let a=Aa{};
assert!(a.borrow()==&amp;a);


//示例说明
let mut a =Some(1);
let b:&amp;Option&lt;i32&gt;=&amp;a;
let b:&amp;Option&lt;i32&gt;=a.borrow();//等价于 &amp;a一样
let b:&amp;mut Option&lt;i32&gt;=&amp;mut a;
let b:&amp;mut Option&lt;i32&gt;=a.borrow_mut();//等价于 &amp;mut a 一样
let b:Option&lt;&amp;i32&gt;=a.as_ref();//得到 Option&lt;&amp;i32&gt; 不可变引用
let b:Option&lt;&amp;mut i32&gt;=a.as_mut();//得到 Option&lt;&amp;i32&gt; 可变引用
let mut c=Box::new(1);
let b:&amp;mut Box&lt;i32&gt;=&amp;mut c;//BOX的可变引用
println!(&quot;{}&quot;,c);
let b:&amp;mut Box&lt;i32&gt;=c.borrow_mut();//等价于 &amp;mut c
println!(&quot;{}&quot;,c);
let b:&amp;i32=c.as_ref();//得到包裹内值引用
let b:&amp;mut i32=c.as_mut();//得到包裹内值可变引用
*b=4;//修改可变引用值
println!(&quot;{}&quot;,c);
let mut t=*c;//可复制值解包为复制
t=5;//解引用在修改值
println!(&quot;{}&quot;,c);
<span class="boring">}
</span></code></pre></pre>
<p>字符串变量</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let o:&amp;'static str = &quot;dddd&quot;;
    let b=o.to_string();
    let c=b.as_str();
    let b1=c.to_string();
    let c1=b1.as_str();
    let k=o.as_ptr();
    let k1=c.as_ptr();
    let k2=c1.as_ptr();
    //k != k1 !=k2
    //每次to_string 都创建新的对象
    println!(&quot;finish&quot;);
}
</code></pre></pre>
<blockquote>
<p>借用需要所有权获得 </p>
</blockquote>
<pre><code>fn aaaa(mut a:&amp;mut String){
    //let t=*a;//借用数据不可转移所有权
    let mut b=a.to_owned();//通过拷贝方式得到所有权
    println!(&quot;{:&gt;}&quot;,b);
    *a=&quot;vff&quot;.to_string();//不转移所有权情况下修改
}
let mut bddd=&amp;mut &quot;sss&quot;.to_string();
aaaa(bddd);
</code></pre>
<blockquote>
<p>转为位置大小类型</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Aa{};
struct Baaa{};
impl Aa for Baaa{}
//let a= Baaa{} as dyn Aa;//错误 a 栈变量，必须知道大小
//let a= Box::new(Baaa{} as dyn Aa）;//错误 临时变量为 栈变量，必须知道大小
let a=Box::new(Baaa{} ) as Box&lt;dyn Aa&gt;;//正确，Box知道大小，内部为堆变量，可未知大小
fn aaa(a: Box&lt;dyn Aa&gt;){}
aaa(a);
let b=&amp;Baaa{} as &amp;dyn Aa;//正确，a为引用指针栈变量，知道大小
fn bbb(a: &amp;dyn Aa){}
bbb(b);
//当类型为未知大小要转类型时可用 &amp; 或 Box 封装
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>各种环境变量使用和示例</p>
</blockquote>
<p><img src="rust/.gitbook/assets/image.png" alt="" /></p>
<blockquote>
<pre><code>单线程
    单所有权
        栈
            整体不变:T
            整体可变:mut T 
            内部可变:
                可复制:Cell&lt;T&gt;
                不可复制:RefCell&lt;T&gt;
        堆:Box&lt;T&gt;
    多所有权
        不变:Rc&lt;T&gt;
        可变:
            可复制:Rc&lt;Cell&lt;T&gt;&gt;
            不可复制:Rc&lt;RefCell&lt;T&gt;&gt;
多线程
    单所有权
        单读单写
            BOOL或INT类型:AtomicT[Bool,i8,i16,i32,i64,isize,u8,u16,u32,usize,ptr]
            任意类型:Mutex&lt;T&gt;
        多读单写:RwLock&lt;T&gt;
    多所有权 [多线程必须包一下]
        不变:Arc&lt;T&gt;
        可变:
            单读单写
                BOOL或INT类型:Arc&lt;AtomicT&gt;
                任意类型:Arc&lt;Mutex&lt;T&gt;&gt;
            多读单写:Arc&lt;RwLock&lt;T&gt;&gt;
</code></pre>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::cell::{Cell, RefCell};
use std::env::var;
use std::rc::Rc;
use std::borrow::{Borrow, BorrowMut};
use std::sync::atomic::{AtomicI32, Ordering};
use std::sync::{Mutex, RwLock};
use std::sync::mpsc::channel;

fn main() {

    var1();
    var2();
    var3();
    var4();
    var5();
    var6();
    var7();
    var8();
    var9();
    var10();
    var11();
    var12();
    var13();
    var14();
}


fn var14(){
    //进程间数据传递
    let (tx, rx) = channel();
    let tx1=tx.clone();
    let t1=thread::spawn(move||{//会把tx所有权转移入闭包,进程退出时释放
        tx.send(11).unwrap();
    });
    t1.join().unwrap();
    let t2=thread::spawn(move ||{//会把tx1所有权转移入闭包,进程退出时释放
        tx1.send(12).unwrap();
    });
    t2.join().unwrap();
    //Sender会在进程时释放
    //使用 rx.iter() 生产者必须完成释放,否则进入阻塞
    for a in rx.iter(){
        println!(&quot;{}&quot;,a);
    }
}

fn var13(){
    //多线程[任意类型]读写
    #[derive(Debug)]
    struct rgt{a:i32}
    let mg:Arc&lt;RwLock&lt;rgt&gt;&gt;=Arc::new(RwLock::new(rgt{a:1}));
    let img1=mg.clone();
    let t1=thread::spawn(move||{
        let mut t=img1.write().unwrap();
        t.a=10;
    });
    let img2=mg.clone();
    let t2=thread::spawn(move ||{
        let mut t=img2.write().unwrap();
        println!(&quot;{:?}&quot;,t.a);
        t.a=11;
    });
    t2.join().unwrap();
    t1.join().unwrap();
    println!(&quot;{:?}&quot;,mg.read().unwrap().a);
}

fn var12(){
    //多线程[任意类型]锁定
    #[derive(Debug)]
    struct mgt{a:i32}
    let mg:Arc&lt;Mutex&lt;mgt&gt;&gt;=Arc::new(Mutex::new(mgt{a:1}));
    let img1=mg.clone();
    let t1=thread::spawn(move||{
        let mut t=img1.lock().unwrap();
        println!(&quot;{:?}&quot;,t);
        t.a=10;
    });
    let img2=mg.clone();
    let t2=thread::spawn(move ||{
        let mut t=img2.lock().unwrap();
        println!(&quot;{:?}&quot;,t);
        t.a=11;
    });
    t2.join().unwrap();
    t1.join().unwrap();
    println!(&quot;{:?}&quot;,mg.lock().unwrap());
}
fn var11(){
    //多线程[整数 布尔] 可变
    let mg:Arc&lt;AtomicI32&gt;=Arc::new(AtomicI32::new(11));
    let img1=mg.clone();
    let t1=thread::spawn(move||{
        img1.fetch_add(1,Ordering::Relaxed);
        println!(&quot;{}&quot;,img1.load(Ordering::Relaxed));
    });
    let img2=mg.clone();
    let t2=thread::spawn(move ||{
        img2.fetch_add(1,Ordering::Relaxed);
        println!(&quot;{}&quot;,img2.load(Ordering::Relaxed));
    });
    t2.join().unwrap();
    t1.join().unwrap();
    println!(&quot;{}&quot;,mg.load(Ordering::Relaxed));
}
fn var10(){
    //多线程不可变
    let mg:Arc&lt;i32&gt;=Arc::new(1);
    let img1=mg.clone();
    let t1=thread::spawn(move||{
        println!(&quot;{}&quot;,img1);
    });
    let img2=mg.clone();
    let t2=thread::spawn(move ||{
        println!(&quot;{}&quot;,img2);
    });
    t2.join().unwrap();
    t1.join().unwrap();
}


fn var9(){
    //多线程唯一所有权
    //Mutex 不能 static
    let tmg:Mutex&lt;i32&gt;=Mutex::new(1);
    {
        let mut b=tmg.lock().unwrap();
        *b=101;
        println!(&quot;{}&quot;,b);
    }
}

//Atomic*系列变量
static ag:AtomicI32=AtomicI32::new(11);
fn var8(){
    //多线程全局简单变量[bool或int][可变]
    let t1=thread::spawn(move ||{
        ag.fetch_add(1,Ordering::Relaxed);
        println!(&quot;{}&quot;,ag.load(Ordering::Relaxed));
    });
    let t2=thread::spawn(move ||{
        ag.fetch_add(1,Ordering::Relaxed);
        println!(&quot;{}&quot;,ag.load(Ordering::Relaxed));
    });
    t1.join().unwrap();
    t2.join().unwrap();
}
fn var7(){
    //多所有权可变 引用可变
    #[derive(Debug)]
    struct at{
        a:i32
    }
    fn myd(t:Rc&lt;RefCell&lt;at&gt;&gt;){}
    let a =Rc::new(RefCell::new(at{a:1}));//a有所有权
    let b=a.clone();//b有所有权
    let c=Rc::downgrade(&amp;a);//c 没有所有权 一般用在重复引用如链表
    //包里的方法有重复 as &amp;RefCell&lt;at&gt; 强制转义
    (a.borrow() as &amp;RefCell&lt;at&gt;).borrow_mut().a=111;
    println!(&quot;{}&quot;,(a.borrow() as &amp;RefCell&lt;at&gt;).borrow().a);//访问
    //对无所有权的获取和赋值
    //注意:需要转移 as Rc&lt;RefCell&lt;at&gt;&gt; 不然编译器无法识别对应类型
    ((c.upgrade().unwrap() as Rc&lt;RefCell&lt;at&gt;&gt;).borrow() as &amp;RefCell&lt;at&gt;).borrow_mut().a=1111;
    println!(&quot;{}&quot;,(a.borrow() as &amp;RefCell&lt;at&gt;).borrow().a);//访问
    myd(b);//消耗b
    myd(a);//消耗a
}
fn var6(){
    //多所有权可变 非引用可变
    fn myd(t:Rc&lt;Cell&lt;i32&gt;&gt;){}
    let a=Rc::new(Cell::new(11));//a有所有权
    let b=a.clone();//b有所有权
    let c=Rc::downgrade(&amp;a);//c 没有所有权 一般用在重复引用如链表
    a.replace(12);
    println!(&quot;{}&quot;,a.get());//访问
    println!(&quot;{:?}&quot;,c.upgrade().unwrap().replace(13));
    println!(&quot;{}&quot;,a.get());//访问
    myd(b);//消耗b
    myd(a);//消耗a
}
fn var5(){
    //多所有权不可变
    #[derive(Debug)]
    struct at{
        a:i32
    }
    fn myd(t:Rc&lt;at&gt;){}
    let a=Rc::new(at{a:1});//a有所有权
    let b=a.clone();//b有所有权
    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    let c=Rc::downgrade(&amp;a);//c 没有所有权 一般用在重复引用如链表
    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    //弱引用没所有权,通过 c.upgrade() 方法拿到弱引用对象
    //当对象未释放时返回,释放时返回none,所以弱引用可以没有所有权
    println!(&quot;{:?}&quot;,c.upgrade().unwrap().a);
    println!(&quot;{}&quot;,a.a);//可直接访问
    //a.a=2;//不可变
    myd(b);//消耗b
    myd(a);//消耗a
    //c.upgrade().unwrap();//这里取弱引用时拿不到 对象已被释放
}
fn var4(){
    fn out()-&gt;Box&lt;i32&gt;{
        //堆中内存分配
        let a=Box::new(11);
        //非栈拷贝,返回胖指针
        return a;
    }
    //t为在堆中内存
    let t=out();
    println!(&quot;{}&quot;,t);
}
fn var3(){
    #[derive(Debug)]
    struct at{
        a:i32
    }
    let t=at{a:1};
    //a外部不可变 内部可变
    let a=RefCell::new(t);//注意这里传入t非&amp;t 但实现&amp;t引用 一般用在结构等
    //取内部可变的引用对象进行修改
    a.borrow_mut().a=11;
    println!(&quot;{:?}&quot;,a);
}
fn var2(){
    //a本身不可变内部可变
    let a=Cell::new(1);
    //替换内部数据
    a.replace(2);
    println!(&quot;{:?}&quot;,a);
}
fn var1(){
    //单线程可变或不可变
    let a=1;
    let mut b=1;//可变
    let c=b+1;
    println!(&quot;{}{}{}&quot;,a,b,c);
}

</code></pre></pre>
<blockquote>
<p>可变值借用后不可变</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let mut b=1;
 let sss= || {
     println!(&quot;{}&quot;,b);
 };
 sss();
 b=2;//编译器能识别 sss 在下文不在使用
// let t=sss;//如果sss在使用，由于可变值借用后不可修改，所以会报错
<span class="boring">}
</span></code></pre></pre>
<p>条件变量示例</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Condvar, Mutex};
use std::thread;
fn main() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair_clone = pair.clone();
    thread::spawn(move || {
        let &amp;(ref lock, ref cvar) = &amp;*pair_clone;
        let mut started = lock.lock().unwrap();
        *started = true;
       cvar.notify_one();
   });
   let &amp;(ref lock, ref cvar) = &amp;*pair;
   let mut started = lock.lock().unwrap();
   while !*started {
       println!(&quot;{}&quot;, started); // false
       started = cvar.wait(started).unwrap();//lock 只能被一个Condvar绑定 lock被多个绑定时完成时只触发第一个
       println!(&quot;{}&quot;, started); // true
   }
}
</code></pre></pre>
<p>Turbofish 操作</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A{}
trait T{ fn b&lt;T&gt;(a:T)-&gt;T;}
impl A{
    fn a&lt;T&gt;(a:T)-&gt;T{
        a
    }
}
impl T for A{
    fn b&lt;T&gt;(a:T)-&gt;T{
        a
    }
}
let a=A::a::&lt;i8&gt;(1);//类型的turbofish操作
let b=T::b::&lt;i8&gt;(1);//trait 的Turbofish操作
//Turbofish 只能用在声明的ITEM上
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>动态类型变量获取类型并调用类型方法</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main() {
    struct A{}
    struct B{}
    trait C{
        fn b()-&gt;i32;
    }
    impl C for A{
        fn b()-&gt;i32{1}
    }
    impl C for B{
        fn b()-&gt;i32{2}
    }
    fn aa()-&gt;Box&lt;impl C&gt;{
        Box::new(A{})
    }
    fn bb()-&gt;Box&lt;impl C&gt;{
        Box::new(B{})
    }
    let t0=aa();
    let t1=bb();
    fn call_bb&lt;T:C&gt;(_:&amp;Box&lt;T&gt;)-&gt;i32{
        T::b()
    }
    println!(&quot;{}&quot;,call_bb(&amp;t0));
    println!(&quot;{}&quot;,call_bb(&amp;t1));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="字符数字转换"><a class="header" href="#字符数字转换">字符数字转换</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::error::Error;
use std::convert::{TryFrom, TryInto};

fn main() {
    //数字转字符串
    let num=1.0/3.0;//浮点数
    let inum=num as i32;//下取整
    let anum=(num as f64).ceil();//向上取整
    let str=num.to_string();
    println!(&quot;{}&quot;,format!(&quot;num:{:.2}str:{}inum:{}anum:{}&quot;,num,str,inum,anum));
    let num=1u8;//U8定义
    let str=num.to_string();
    println!(&quot;{}&quot;,format!(&quot;num:{}str:{}&quot;,num,str));
    let num=b'c';//U8定义
    let str=num.to_string();
    println!(&quot;{}&quot;,format!(&quot;num:{}str:{}&quot;,num,str));
    let num=1i32;//8位整数
    let str=num.to_string();
    println!(&quot;{}&quot;,format!(&quot;num:{}str:{}&quot;,num,str));
    let num=1.01f32;//32位浮点
    let str=num.to_string();
    println!(&quot;{}&quot;,format!(&quot;num:{:.2}str:{}&quot;,num,str));
    //char 字符类型 u8 i* 都是整数
    let a= '1' as i32 as u8 as char;
    let b=49i32 as i8 as u8 as char;
    println!(&quot;{}{}&quot;,a,b);
    //字符串转数字
    let num=&quot;1&quot;.parse::&lt;i32&gt;().unwrap();
    println!(&quot;{}&quot;,num);
    let num=&quot;??&quot;.parse::&lt;i32&gt;();
    if num.is_err() {
        println!(&quot;{}&quot;,num.unwrap_err().to_string());
    }
    let num=&quot;1.11111111&quot;.parse::&lt;f32&gt;().unwrap();
    println!(&quot;{}&quot;,num);
    //自定义类型转换
    #[derive(Debug)]
    struct mynum{
        a:i32,
        b:i32
    }
    impl From&lt;String&gt; for mynum{
        fn from(str: String) -&gt; Self {
            let split=str.split(&quot;,&quot;);
            let n=split.collect::&lt;Vec&lt;_&gt;&gt;();
            if(n.len()&lt;2){
                return mynum{
                    a:0,
                    b:0
                };
            }
            let a:i32=n[0].parse::&lt;i32&gt;().unwrap();
            let b:i32=n[1].parse::&lt;i32&gt;().unwrap();
            return mynum{
                a:a,
                b:b
            }
        }
    }
    #[derive(Debug)]
    struct mynum1{
        a:i32,
        b:i32
    }
    impl TryFrom&lt;String&gt; for mynum1{
        type Error = &amp;'static str;
        fn try_from(str: String) -&gt; Result&lt;Self, Self::Error&gt; {
            let split=str.split(&quot;,&quot;);
            let n=split.collect::&lt;Vec&lt;_&gt;&gt;();
            if(n.len()&lt;2){
                return Err(&quot;bad&quot;);
            }
            let a:i32=n[0].parse::&lt;i32&gt;().or_else(|e|Err(&quot;a bad&quot;))?;
            let b:i32=n[1].parse::&lt;i32&gt;().or_else(|e|Err(&quot;b bad&quot;))?;
            return Ok(mynum1{
                a:a,
                b:b
            });
        }
    }
    let mn:Result&lt;mynum1, &amp;str&gt;=&quot;1,1&quot;.to_string().try_into();
    println!(&quot;{:?}&quot;,mn.unwrap());
    
    let a:i32=1;
    let b:usize=1;
    if(a==(b as i32)){要强制转义才可以
        //
    }
    
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="所有权-ownership"><a class="header" href="#所有权-ownership">所有权 ownership</a></h2>
<p>结构所有权</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct bbb{
}
//struct enum 默认非copy,需要手动实现
#[derive(Debug,Copy, Clone)]
struct cpbbb{
}
#[derive(Debug)]
struct aaa{
    var1:bbb,
    var2:i32
}
#[derive(Debug,Copy, Clone)]
struct cpaaa{
    //var1:bbb,//如果外部可copy,所有内部也必须可copy,bbb不可copy所以错误
    var2:cpbbb
}
fn tt(c:aaa){
    println!(&quot;{:?}&quot;,c);
}
fn main() {
    //----------------------
    let a=cpaaa{
        var2: cpbbb{}
    };

    //----------------------
    //数组,元组,Option如果内值可复制,则实现复制
    let a=[bbb{}];
    let b=a;//bbb 非复制,所以a所有权转移到b
    //println!(&quot;{:?}&quot;,a);//a 未定义
    let ca=[cpbbb{}];
    let cb=ca;
    println!(&quot;{:?}&quot;,ca);//cb复制ca 不转移

    let a=(bbb{});
    let b=a;//bbb 非复制,所以a所有权转移到b
    //println!(&quot;{:?}&quot;,a);//a 未定义
    let ca=(cpbbb{});
    let cb=ca;
    println!(&quot;{:?}&quot;,ca);//cb复制ca 不转移

    let a=Some(bbb{});
    let b=a;//bbb 非复制,所以a所有权转移到b
    //println!(&quot;{:?}&quot;,a);//a 未定义
    let ca=Some(cpbbb{});
    let cb=ca;
    println!(&quot;{:?}&quot;,ca);//cb复制ca 不转移

    //----------------------
    let mut a =aaa{
        var1:bbb{},
        var2:1
    };
    let b=a.var2;
    let c=a.var1;//结构里的一个所有权被转移会导致整个结构不可用
    a.var1=c;//转移回去会正常
    tt(a);

}
</code></pre></pre>
<p>变量范围所有权</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct aaa{
    a:i32
}
#[derive(Debug,Copy, Clone)]
struct bbb{
    b:i32
}

fn main() {
    //----------------
    let mut a =aaa{a:1};
    let mut b=bbb{b:1};
    {
        let c=a;//a已转移到c
        let d=b;//可复制,不转移所有权
        //c d 释放
    }
    //println!(&quot;{:?}&quot;,a);//a 已被转移,未定义
    println!(&quot;{:?}&quot;,b);


    //--------------------
    let mut a =aaa{a:1};
    {
        let c=a;//a已转移到c
        a=aaa{a:1};//a重新被赋值
    }
    println!(&quot;{:?}&quot;,a);//a已重新赋值,存在

    //-------------
    let mut a =aaa{a:1};
    {
        let c=&amp;mut a;//未被转移,可变引用
        c.a=2;
    }
    println!(&quot;{:?}&quot;,a);//a已重新赋值,存在 aaa{a:2}

    //-------------
    //转移到空变量
    let t =aaa{a:1};
    t;//注意 t被转移 之后不在可用
    //let c=t;//t 不在可用
    let t =aaa{a:1};
    {
        t;//t被转移 之后不在可用
    }
    //println!(&quot;{:?}&quot;,t);//t 已在{}被转移

    //-------------
    //闭包
    let a=aaa{a:1};
    let b=bbb{b:1};
    let fc=||{
        //对于复制语义类型，以不可变引用（&amp;T）来进行捕获
        //生成闭包结构类似为 b=b
        let t=b;
        //执行移动语义，转移所有权来进行捕获
        ////生成闭包结构类似为 a=a
        let t1=a;
        //let t1=&amp;a;//可以用引用方式来实现不转移所有权
    };
    fc();
    println!(&quot;{:?}&quot;,b);
    //println!(&quot;{:?}&quot;,a);//a已被转移到闭包,a不在可用

    //闭包
    let mut a =aaa{a:1};
    let mut b=bbb{b:1};
    let mut fc=||{
        //可变绑定,在闭包中进行修改的操作，以可变引用捕获
        //生成闭包结构类似为 &amp;mut b=b
        b.b=2;
        //生成闭包结构类似为 &amp;mut a=a
        a.a=2;
    };
    fc();
    println!(&quot;{:?}&quot;,b);//所有权未被转移
    println!(&quot;{:?}&quot;,a);//所有权未被转移

    //闭包
    let b =bbb{ b: 0};
    let fc=move ||{
        let t=b;//复制语义不转移所有权
    };
    fc();
    fc();
    println!(&quot;{:?}&quot;,b);//所有权未被转移

    //闭包
    let a =aaa{ a: 0};
    let fc=move ||{//FnOnce
        let t=a;//非复制语义转移所有权
    };
    fc();
    //fc();//self被消耗
    //println!(&quot;{:?}&quot;,a);//所有权被转移

    //闭包
    //Fn : FnMut : FnOnce
    let b =bbb{ b: 0};
    let fc=||{//Fn 可多次调用,不改变环境
        let t=b;
    };
    fc();
    fc();
    let mut a =aaa{ a: 0};
    let mut fc=||{//FnMut 可多次调用,改变环境
        a.a=1;
    };
    fc();
    fc();
    let a =aaa{ a: 0};
    let fc=||{//FnOnce 只调用一次,消耗自身
        let t=a;
    };
    fc();
    //fc();//不可二次调用

}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="生命周期-lifetime"><a class="header" href="#生命周期-lifetime">生命周期 lifetime</a></h2>
<p>生命周期示例</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::borrow::Borrow;

//'a 为声明周期参数,必须先声明
fn aa1&lt;'a&gt;()-&gt;&amp;'a str{
    //声明后生命周期参数可用
    let a:&amp;'a str=&quot;ddd&quot;;//虽然声明a为'a 但a指向的内容为'static
    return a;//返回'static 引用合法
}
// fn aa4&lt;'a&gt;()-&gt;&amp;'a i32{
//     let i=11;
//     let b:&amp;'a i32=&amp;i;
//     return b;//返回局部变量引用非法
// }
fn aa2&lt;'a&gt;()-&gt;&amp;'a str{
    //声明后生命周期参数可用
    let mut a:String=&quot;ddd&quot;.to_string();
    //as_ref 会返回新建立的str的局部变量
    // 不能返回局部变量引用,所以会出错
    // return a.as_ref();
    return &quot;dddd&quot;;//为'static &gt;='a 所以可返回
}
// fn aa5()-&gt;&amp;'static str{
//     let mut a:String=&quot;ddd&quot;.to_string();
//     //短生命周期数据不能转为长生命周期
//     let b:&amp;'static str=a.as_ref();
//     return b;
// }
//'b:'a 为 存活时间 'b&gt;='a
//主要作用为标识
fn aa3&lt;'a,'b:'a&gt;(str1:&amp;'a str,str2:&amp;'b str)-&gt;&amp;'a str{
    //str1 str2 的生命周期告诉编译器传入变量那个会存活更久
    return str1;
}
//待生命周期参数结构
#[derive(Debug)]
struct at&lt;'t&gt;{
    a:&amp;'t str
}
//'b:'a 为 存活时间 'b&gt;='a
fn saa&lt;'a,'b:'a&gt;(s:i32,tmp:&amp;'a at&lt;'a&gt;,tmp2:&amp;'b at&lt;'b&gt;)
                 -&gt;&amp;'a at&lt;'a&gt;{//返回&amp;'b at&lt;'a&gt;也可以,会以结构体'a为准
    if s&gt;1 {
        return tmp;
    }else{
        return tmp2;
    }
}
//带生命周期的trait
trait Atr&lt;'a&gt;{}
impl &lt;'a&gt; Atr&lt;'a&gt; for at&lt;'a&gt;{
}
////返回如果是指定结构,需要执行生命周期 at&lt;'a&gt;
fn out&lt;'a&gt;(s:&amp;'a str)-&gt;Box&lt;at&lt;'a&gt;&gt;{
    Box::new(at{
        a:s
    })
}
//返回如果是 trait 对象的话 需要使用 Atr&lt;'a&gt;+'a
fn foo&lt;'a&gt;(s:&amp;'a str)-&gt;Box&lt;Atr&lt;'a&gt;+'a&gt;{//注意点
    Box::new(at{
        a:s
    })
}
//返回的值小于传入的任何一个,所以要返回'a
//带生命周期结构必须把生命周期带上
fn main() {
    //'static 全局声明周期
    let b:&amp;'static str=&quot;dddd&quot;;
    let c=b.to_string();
    let c1:&amp;str=b.as_ref();
    let b:&amp;str=aa1();
    let b:&amp;str=aa2();
    let b:&amp;str=aa3(&quot;1&quot;,&quot;2&quot;);
    let b:String =&quot;bbb&quot;.to_string();
    let va=&amp;at{
        a:b.as_str()//可多次借用
    };
    let vc:&amp;at;//老版本的有问题.
    let vb=&amp;at{
        a:b.as_str()//可多次借用
    };
    vc=saa(1,va,vb);
    let c=out(&quot;tmp&quot;);
    println!(&quot;{:?},{:?}&quot;,vc,c);
    let raw=&quot;SSS&quot;.to_string();
    let b=raw.as_str();
    let b1=vec![1];
    let c=&amp;b1[..];
    thread::spawn(move ||{
        //println!(&quot;{:?}&quot;,c);//&amp;str 切片不可跨线程传
        //println!(&quot;{}&quot;,b);//&amp;str 切片不可跨线程传
        println!(&quot;{}&quot;,raw);
    }).join().unwrap();
}
</code></pre></pre>
<p>’static生命周期</p>
<pre><pre class="playground"><code class="language-rust">use rand;
fn aa()-&gt;&amp;'static i32{
    //静态编码,String 都是'static生命周期
    let str_literal: &amp;'static i32 = &amp;1;
    //例如这里直接返回 String, String 对象来说是'static生命周期的
    return str_literal;
}
fn rand_str_generator() -&gt; &amp;'static str {
    //不一定硬编码的才是'static 生命周期,如主动释放的也可以
    let rand_string = &quot;sss&quot;.to_string();
    Box::leak(rand_string.into_boxed_str())
}
fn main() {
    let b=1;//所有权的变量生命周期也是'static
    let c=aa();
    println!(&quot;{}&quot;,c);
    let cc=rand_str_generator();
}
</code></pre></pre>
<p>方法体self的生命周期</p>
<pre><pre class="playground"><code class="language-rust">
fn main() {
    //不可变借用.可以多次,所以'a内生命周期不需要释放
    struct abb&lt;'a&gt;(&amp;'a i32);
    impl&lt;'a&gt; abb&lt;'a&gt;{
        fn a1(&amp;'a  self) -&gt; &amp;'a i32 {
            return self.0;
        }
        fn a2(&amp;'a  self) -&gt; &amp;'a i32 {
            return self.0;
        }
    }
    let mut a =abb(&amp;1);
    a.a1();
    a.a2();

    //可变借用.可以同时只能借一次
    //声明了&amp;'a mut self
    // 导致:调用aab1以'a生命周期调用a1方法 返回时应为'a的生命周期所以不释放自身的可变借用
    // 所以不能再调用第二次
    struct abb1&lt;'a&gt;(&amp;'a i32);
    impl&lt;'a&gt; abb1&lt;'a&gt;{
        fn a1(&amp;'a mut self) -&gt; &amp;'a i32 {
            return self.0;
        }
        fn a2(&amp;'a mut self) -&gt; &amp;'a i32 {
            return self.0;
        }
    }
    let mut a =abb1(&amp;1);
    a.a1();
    //a.a2();//再次调用会出错. 以为声明 &amp;'a mut self 关系


    //可变借用.可以同时只能借一次
    //声明了&amp;'_ mut self
    // 导致:调用aab1以'_生命周期调用a1方法
    //当返回时,'_的生命周期作用于当前函数,所以会释放self的可变借用
    // 所以可以再次调用
    struct abb2&lt;'a&gt;(&amp;'a i32);
    impl&lt;'a&gt; abb2&lt;'a&gt;{
        //'_ 其实就是一个临时生命周期,默认系统会填充
        fn a1(&amp;'_ mut self) -&gt; &amp;'a i32 {
            return self.0;
        }
        //'_ 其实就是一个临时生命周期,默认系统会填充
        fn a2(&amp;'_ mut self) -&gt; &amp;'a i32 {
            return self.0;
        }
        //'b 不用系统填充的,自己定义
        fn a3&lt;'b&gt;(&amp;'b mut self) -&gt; &amp;'a i32 {
            return self.0;
        }
    }
    let mut a =abb2(&amp;1);
    a.a1();
    a.a2();
    a.a3();
}




</code></pre></pre>
<p>泛型结构字段非字段生命周期</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker;
struct Iter&lt;'a, T: 'a&gt; {
    ptr: *const T,
    end: *const T,
    _marker: marker::PhantomData&lt;&amp;'a T&gt;,//特殊结构
}
//枚举使用 PhantomData
enum ValueBind&lt;'q,'t:'q,T&gt;where T:'q + Send
{
        a(&amp;'t T),
        _tmp(std::convert::Infallible, std::marker::PhantomData&lt;&amp;'q T&gt;),
}
let _=ValueBind::a(&amp;1);
<span class="boring">}
</span></code></pre></pre>
<p>静态生命周期跟堆变量生命周期</p>
<pre><pre class="playground"><code class="language-rust">struct Inspector&lt;'a&gt;(&amp;'a u8);

struct Inspector1(&amp;'static str);

impl&lt;'a&gt; Drop for Inspector1 {
    fn drop(&amp;mut self) {
        println!(&quot;{}&quot;, self.0);
    }
}

fn main() {
    let (inspector, days); //生命周期 inspector&gt;days
    days = Box::new(1);//当为Box因为在堆中
    inspector = Inspector(&amp;days);//Inspector未实现 且Drop堆中正常编译
    // let days=1;
    // inspector = Inspector(&amp;days);//days会比inspector先释放,无法编译

    let (inspector1, days1); //生命周期 inspector&gt;days
    days1 = &quot;ssss&quot;;
    inspector1 = Inspector1(&amp;days1);//当days1为static时正常编译
    //如果Inspector1的str非'static 无法编译

}
</code></pre></pre>
<p>未在结构的生命周期</p>
<pre><pre class="playground"><code class="language-rust">trait Ba&lt;'c,T&gt;{
    fn a(a: &amp;'c T)-&gt;&amp;'c T{
        return a;
    }
}
struct TT{}
impl&lt;'c,T&gt; Ba&lt;'c,T&gt; for TT {}
struct Ptype&lt;'c,T&gt;//类型 生命周期或泛型未使用在字段时 PhantomData 关联两者关系
    where
        T:Ba&lt;'c,i32&gt;,
{
    a:T,
    _marker:std::marker::PhantomData&lt;&amp;'c T&gt;
}
fn main() {
    let t=TT{};
    let t1=Ptype{
        a:t,
        _marker: Default::default()
    };
}
</code></pre></pre>
<blockquote>
<p>闭包指定生命周期</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let identity: &amp;dyn for&lt;'a&gt; Fn(&amp;'a i32) -&gt; &amp;'a i32 = &amp;|x: &amp;i32| x;
let b=identity(&amp;1);
println!(&quot;{}&quot;,b as &amp;i32);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="字符串"><a class="header" href="#字符串">字符串</a></h2>
<p>字符串操作</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {

    //其他类型格式化为字符串
    println!(&quot;{}&quot;,format!(&quot;test{},hi&quot;,11));

    let mut str1 =&quot;的te都st&quot;.to_string();
    //str1==str2
    //UTF8获取和查找
    println!(&quot;{}&quot;,str1.get(0..3).unwrap());//取内部某给部分,完整字符边界,否则出错
    //包含字符
    println!(&quot;{:?}&quot;,str1.contains(&quot;t&quot;));//是否包含某字符
    println!(&quot;{:?}&quot;,str1.contains(char::is_lowercase));//通过回调函数判断,是否存在小写字符
    println!(&quot;{:?}&quot;,str1.starts_with(&quot;的&quot;));//是否某字符串开头
    println!(&quot;{:?}&quot;,str1.ends_with(&quot;st&quot;));//是否某字符串结尾
    //查找字符
    println!(&quot;{:?}&quot;,str1.find(&quot;t&quot;).unwrap_or(0));//正向查找某字符,完整字符边界,否则出错
    println!(&quot;{:?}&quot;,str1.rfind(&quot;t&quot;).unwrap_or(0));//反向查找某字符,完整字符边界,否则出错
    //拆分
    println!(&quot;{:?}&quot;,str1.split_at(3));//完整字符边界,否则出错
    println!(&quot;{:?}&quot;,str1.split(&quot;s&quot;));//完整字符边界,否则出错
    println!(&quot;{:?}&quot;,str1.split_terminator(&quot;s&quot;));//完整字符边界,否则出错
    println!(&quot;{:?}&quot;,str1.rsplit(&quot;s&quot;));//完整字符边界,否则出错
    //模式匹配
    let mstr=&quot;cccbbbccc&quot;.to_string();
    let matstr=mstr.matches(&quot;c&quot;).collect::&lt;Vec&lt;&amp;str&gt;&gt;();//得到匹配的集合
    println!(&quot;{:?}&quot;,matstr);
    let matstr=mstr.rmatches(&quot;c&quot;).collect::&lt;Vec&lt;&amp;str&gt;&gt;();//反向得到匹配的集合
    println!(&quot;{:?}&quot;,matstr);
    let matstr=mstr.match_indices(&quot;c&quot;).collect::&lt;Vec&lt;_&gt;&gt;();//反向得到匹配的索引和集合
    println!(&quot;{:?}&quot;,matstr);
    let matstr=mstr.rmatch_indices(&quot;c&quot;).collect::&lt;Vec&lt;_&gt;&gt;();//反向得到匹配的索引和集合
    println!(&quot;{:?}&quot;,matstr);

    //UTF8添加
    str1.push('c');//添加字符
    str1.push_str(&quot;cc&quot;);//添加字符串
    str1.extend(vec!['a','b','c']);//添加迭代器字符
    //自定位置添加
    str1.insert(0,'a');
    str1.insert_str(0,&quot;开头00&quot;);
    //连接符添加
    str1+=&quot;++&quot;;

    //UTF8删除
    let pchar=str1.pop();//删除最后一个字符
    str1.remove(0);//删除并返回指定字符
    let tmp=str1.drain(0..5);//删除并返回自定字符串drain 完整字符边界
    let tmpstr:String=tmp.collect();//转为字符串
    println!(&quot;{}&quot;,tmpstr);
    str1.truncate(5);//截断到指定长度 完整字符边界
    println!(&quot;{}&quot;,str1);
    //匹配两边删除 trim 系列函数
    let delstr=&quot;sssbbbccc&quot;.to_string();
    println!(&quot;{}&quot;,delstr.trim_matches('c'));

    //UTF8字符替换
    let delstr=&quot;sssbbbbccc&quot;.to_string();
    println!(&quot;{}&quot;,delstr.replace(&quot;bb&quot;,&quot;kk&quot;));//全量替换
    println!(&quot;{}&quot;,delstr.replacen(&quot;c&quot;,&quot;s&quot;,1));//限制次数替换

    //字符串常用迭代
    //迭代一般为转为其他形态做中间变量,如转为容器或截取部分迭代内容
    //转为字符迭代
    let chars=str1.chars();
    for mychar in chars {
        println!(&quot;{}&quot;,mychar);
    }
    //转为字符迭代 (字符长度,字符)
    let chars=str1.char_indices();
    for mychar in chars {
        println!(&quot;{:?}&quot;,mychar);
    }
    //转为U8[整数]迭代
    let chars=str1.bytes();
    for mychar in chars {
        println!(&quot;{}&quot;,mychar);
    }

    //字符串安全操作转换: 类型&lt;-collect-&gt;迭代器&lt;-collect-&gt;Vec&lt;char|u8&gt;
    //替换字符串
    let mut b =&quot;sss发的bbb&quot;.chars().collect::&lt;Vec&lt;char&gt;&gt;();
    //修改容器里的值
    b[4]='非';
    //容器还原为迭代器,在把迭代器转为String
    let t=b.into_iter().collect::&lt;String&gt;();
    println!(&quot;{}&quot;,t);

    //范围获取字符串
    let mut s = String::from(&quot;α is alpha, 的 is beta&quot;);
    let mut s1 =s.chars().collect::&lt;Vec&lt;char&gt;&gt;();
    let s2=s1.drain(0..2);
    let s2=s2.collect::&lt;String&gt;();
    let s1=s1.into_iter().collect::&lt;String&gt;();
    println!(&quot;s1:{:?}\ns2:{:?}&quot;,s1,s2);

}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="rust与c相互调用"><a class="header" href="#rust与c相互调用">RUST与c相互调用</a></h2>
<p>Cargo.toml</p>
<pre><code>[build-dependencies]
bindgen = &quot;~0.58.1&quot; #绑定C函数到rust
cc = &quot;~1.0.61&quot;#编译C程序成库,编译器功能
#cbindgen = &quot;~0.19&quot; #根据rust库创建C的头文件
[lib] #非必须
crate-type = [&quot;cdylib&quot;,&quot;lib&quot;] # 如果定义了 crate-type 一定要有lib main.rs才能使用本身 lib.rs中的定义
</code></pre>
<blockquote>
<p>build.rs</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main(){
	//编译环境变量
	//println!(&quot;cargo:rustc-env=VAR=VALUE&quot;);
	
	//C 编译flags 支持 -l 或 -L 等于使用 rustc-link-lib 或 rustc-link-search
	//println!(&quot;cargo:rustc-flags = \&quot;-L /some/path\&quot;&quot;);
	
	//RUST 条件编译,等于编译参数 --cfg ,用在条件编译 #[cfg(key)]
	//println!(&quot;cargo:rustc-cfg = ['key=\&quot;value\&quot;']&quot;);
	//println!(&quot;cargo:rustc-cfg = ['key']&quot;);
	
	//指定文件变更编译
	println!(&quot;cargo:rerun-if-changed=c_src/mytest.c&quot;);
	println!(&quot;cargo:rerun-if-changed=c_src/mytest.h&quot;);
    //使用库
    //库目录 在 /etc/ld.so.conf.d/ 增加SO的加载路径 或者用 `LD_LIBRARY_PATH=./c_src cargo run` 或
    // println!(&quot;cargo:rustc-link-search=native={}&quot;, std::path::Path::new(
    //     &amp;std::env::var(&quot;CARGO_MANIFEST_DIR&quot;).unwrap().to_string()
    // ).join(&quot;c_src&quot;).to_str().unwrap());//添加库目录
    // println!(&quot;cargo:rustc-link-lib=dylib=add&quot;);//动态库 搜索库目录中的libadd.so 或libadd.dll
    // println!(&quot;cargo:rustc-link-lib=static=add&quot;);//静态库 搜索库目录中的libadd.a 或libadd.lib
    //从C源码编译库
    cc::Build::new()
        .warnings(true)
        .flag(&quot;-Wall&quot;)
        .flag(&quot;-c&quot;)
        .file(&quot;c_src/mytest.c&quot;)
        .out_dir(&quot;my_dir&quot;)//自定义共享库生成路径
        .compile(&quot;myout&quot;);//编译出来的库名,会自动增加到当前编译环境
    //C头文件转为 RUST文件
    let bindings = bindgen::Builder::default()
        .header(&quot;c_src/mytest.h&quot;)
        .generate()
        .expect(&quot;Unable to generate bindings&quot;);
    let out_path = std::path::PathBuf::from(&quot;src&quot;);
    let generated_path = out_path.join(&quot;bindcres.rs&quot;);
    bindings
        .write_to_file(&amp;generated_path)
        .expect(&quot;Unable to write output file&quot;);
}
</code></pre></pre>
<blockquote>
<p>c_src/mytest.c</p>
</blockquote>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &quot;mytest.h&quot;
int mytest(int a,char *str){
    char * t=&quot;ddd&quot;;
    printf(&quot;%d,%s,%s&quot;,a,str,t);
    return a+1;
}
char *a=NULL;
char* getstr(){
    a=strdup(&quot;中文..&quot;);
    return a;
}
void freestr(){
    if(!a)free(a);
}
</code></pre>
<blockquote>
<p>c_src/mytest.h</p>
</blockquote>
<pre><code class="language-c">#ifndef MYTESTLIB_FFF_H
#define MYTESTLIB_FFF_H
int mytest(int a,char *str);
char* getstr();
void freestr();
#endif //MYTESTLIB_FFF_H
</code></pre>
<blockquote>
<p>src/lib.rs</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>include!(&quot;bindcres.rs&quot;);//存在main.rs 跟 lib.rs 时,只能在lib.rs 中引用
use std::ffi::CStr;
use std::os::raw::c_char;
#[no_mangle]
pub fn out_str() -&gt;String{
    let c_str: &amp;CStr = unsafe {
        let c_buf: *const c_char =getstr();
        CStr::from_ptr(c_buf)//从C字符串转为RUST的CSTR
    };
    let str_slice:String = c_str.to_str().unwrap().to_owned();//CSTR转为&amp;str在转为String
    println!(&quot;form c str:{}&quot;,str_slice);
    unsafe {freestr();};//主动释放
    str_slice
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>src/main.rs</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::ffi::{CString};
use untitled1::out_str;
use untitled1::mytest;
fn main(){
    let b=out_str();
    println!(&quot;rustout:{}&quot;,b);
    let str=&quot;bb&quot;.to_string();
    let c_to_print=CString::new(str).unwrap();//RUST字符串转为 C字符串
    let a;
    unsafe {
        let b=c_to_print.as_ptr() as *mut i8;
        a=mytest(1,b);//一定要在这里进行c_to_print.as_ptr()调用 外部调用出错
    }
    println!(&quot;rustout:{}&quot;,a);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creat"><a class="header" href="#creat">creat</a></h1>
<blockquote>
<p>添加编译目标支持</p>
</blockquote>
<pre><code>rustup target add wasm32-wasi
</code></pre>
<blockquote>
<p>编译指定平台目标</p>
</blockquote>
<pre><code>cargo run --target wasm32-wasi
</code></pre>
<blockquote>
<p>扩展宏</p>
</blockquote>
<pre><code>cargo +nightly install cargo-expand
</code></pre>
<blockquote>
<p><code>futures</code> 默认包含运行时和channel <code>futures-executor</code> 不需要可用 <code>futures-util</code> [例如用运行时:async-std,tokio,运行时一般也内置channel]  <code>futures-channel</code> 被导出为 <code>channel</code></p>
</blockquote>
<blockquote>
<p><code>async-std</code> 默认不包含 #[async_std::main],需要指定 features <code>attributes</code></p>
</blockquote>
<blockquote>
<p><code>tokio</code> 默认不包含 #[tokio::main],需要指定 features <code>macros</code></p>
</blockquote>
<p>cargo.toml </p>
<pre><code>#多个crate时使用,一般会将项目拆分成多个crate
[workspace]
members = [
    &quot;.&quot;,
    &quot;m1&quot;
]

[package]
name = &quot;untitled2&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;
# 默认运行的入口
default-run=&quot;cool&quot;
[dependencies]
m1 = { version = &quot;0.1.0&quot;, path = &quot;./m1&quot;}


# 多个可执行文件配置
[[bin]]
name = &quot;cool&quot;
path = &quot;src/main.rs&quot;

[[bin]]
name = &quot;frobnicator&quot;
path = &quot;src/main1.rs&quot;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="宏示例"><a class="header" href="#宏示例">宏示例</a></h2>
<blockquote>
<p>macro_rules</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">#![feature(trace_macros)]
//1. 确定宏生成结果,确认循环点 [输出结果]
// let out={
//     let len=&lt;[()]&gt;::len([()]);//内部()循环N次
//     let mut a =::std::collections::HashMap::with_capacity(len);
//     a.insert(1,2);//循环N次
//     a
// };
//2. 确定调用示例 [输入样式]
//let out=myhash!{1=&gt;2,3=&gt;3};
//3. 合并两者
macro_rules! myhash {
    //通过特别前缀的输入规则来拆分多个宏
    (tounit $push_key:tt)=&gt;{()};//输入任何数据都输出(),生成跟输入无关数据
    (count $($push_key:tt),*)=&gt;(//不能跨宏定义变量在使用
         &lt;[()]&gt;::len(&amp;[$( myhash!(tounit $push_key) ,)*]);
    );
    ($($push_key:expr=&gt;$push_val:expr),* $(,)?) //根据输入示例编写输入规则
    =&gt;{ //根据输出结果写输出
        {//这个非必须.根据示例生成的
          let len= myhash!(count $($push_key),*);//如果len在 myhash!(count )里定义 下面使用将报错
          let mut a =::std::collections::HashMap::with_capacity(len);
          $(a.insert($push_key,$push_val);)* //这个根据结果生成
          a
        }
    };
}

// $($push_key:expr),*
// $(匹配关键字:匹配类型)连接字符 出现次数
// 上面只匹配 a,b 而不匹配 a,b, 因为多了 , 结尾

macro_rules! lopreg {
    ($($push_key:expr),* $(,)?)
    // 通过$push_key在下面使用 $(,) 无法在内容中使用,但可用于匹配输入
    //匹配只能用于全匹配
    =&gt;{
        $($push_key);+ ;//用;连接,最后一个没有;
        $($push_key;)+ //每个元素都有 ;
        //最后一个+ 用于输出次数,但循环有输入解决等于制约输入循环次数
    };
}


fn main() {
    lopreg!(1,2,3);
    //4. 测试宏
    //trace_macros!(true); //开启调试,影响当前及以下mod,上层不影响
    // cargo rustc -- -Z unstable-options --pretty=expanded 展开宏后代码
    // 存在lib.rs 跟 main.rs 时指定编译目标
    // cargo rustc --lib  -- -Z unstable-options --pretty=expanded 
    // cargo rustc --bin untitled -- -Z unstable-options --pretty=expanded
    //或使用 cargo expand 但宏有问题时输出异常,并无提示
    // myhash!{1=&gt;2,3=&gt;3,2=&gt;1};
    // a::a();
}
mod a{
    pub fn a(){
        myhash!{1=&gt;2};
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="proc-macro-使用后不能使用macro_rules定义"><a class="header" href="#proc-macro-使用后不能使用macro_rules定义">proc-macro 使用后不能使用macro_rules!定义</a></h2>
<p>引入包</p>
<pre><code>[lib]
proc-macro = true
[dependencies]
syn = {version = &quot;~1.0.74&quot;,features = [&quot;full&quot;]}
quote = &quot;~1.0.9&quot;
proc-macro2 = &quot;~1.0.28&quot;
</code></pre>
<p>3种类型宏定义和使用</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proc_macro::{TokenStream};
use quote::quote;
use proc_macro2::{Ident, Span};
use syn::{DataStruct, Data, Fields, parse_macro_input, DeriveInput, Meta, NestedMeta};

//类函数宏
#[proc_macro]
pub fn my_proc_macro(ident: TokenStream) -&gt; TokenStream {
    let new_func_name = format!(&quot;test_{}&quot;, ident.to_string());
    let concated_ident = Ident::new(&amp;new_func_name, Span::call_site());
    let expanded = quote! {
        fn #concated_ident&lt;T: std::fmt::Debug&gt;(t: T) {
            println!(&quot;{:?}&quot;, t);
        }
    };
    expanded.into()
}
//使用示例
// untitled::my_proc_macro!(hello);


// syn::parse_macro_input
// 1. 方法返回的可以直接用在 quote!{} 里面,整个输入的数据
// 2. 返回按类型生成的结构体,可以访问里面内容进行获取数据,如结构体名,函数名等

// quote::format_ident
// 1. 可将字符串转为token

//继承宏,确定不会有参数时使用
#[proc_macro_derive(Show)]
pub fn derive_show(item: TokenStream) -&gt; TokenStream { //生成的结果不用 derive_show
    // 解析整个token tree
    let input = parse_macro_input!(item as DeriveInput);
    let struct_name = &amp;input.ident; // 结构体名字
    // 提取结构体里的字段
    let expanded = match input.data {
        Data::Struct(DataStruct{ref fields,..}) =&gt; {
            if let Fields::Named(ref fields_name) = fields {
                // 结构体中可能是多个字段
                let get_selfs: Vec&lt;_&gt; = fields_name.named.iter().map(|field| {
                    let field_name = field.ident.as_ref().unwrap(); // 字段名字
                    quote! {
                        &amp;self.#field_name
                    }
                }).collect();

                let implemented_show = quote! {
                // 下面就是Display trait的定义了
                // use std::fmt; // 不要这样import，因为std::fmt是全局的，无法做到卫生性(hygiene)
                // 编译器会报错重复import fmt当你多次使用Show之后
                impl std::fmt::Display for #struct_name {
                    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
                        // #(#get_self),*，这是多重匹配，生成的样子大概是这样：&amp;self.a, &amp;self.b, &amp;self.c, ...
                        // 用法和标准宏有点像，关于多个匹配，可以看这个文档
                        // https://docs.rs/quote/1.0.0/quote/macro.quote.html
                        write!(f, &quot;{} {:?}&quot;, stringify!(#struct_name), (#(#get_selfs),*))
                    }
                }
            };
                implemented_show

            } else {
                panic!(&quot;sorry, may it's a complicated struct.&quot;);
            }
        }
        _ =&gt; panic!(&quot;sorry, Show is not implemented for union or enum type.&quot;)
    };
    expanded.into()
}
// 使用示例
// #[derive(untitled::Show)]
// struct A {}



// 属性宏 有参数时使用
#[proc_macro_attribute]
pub fn run_time(args: TokenStream, item: TokenStream) -&gt; TokenStream {

    // 作用的结构体上
    //let func = syn::parse_macro_input!(item as syn::DeriveInput);

    // 作用在函数体上
    let func = syn::parse_macro_input!(item as syn::ItemFn);
    let func_vis = &amp;func.vis; // pub
    let func_block = &amp;func.block; // 函数主体实现部分{}
    let func_decl = &amp;func.sig; // 函数申明
    let func_name = &amp;func_decl.ident; // 函数名
    let func_generics = &amp;func_decl.generics; // 函数泛型
    let func_inputs = &amp;func_decl.inputs; // 函数输入参数
    let func_output = &amp;func_decl.output; // 函数返回
    // 提取参数，参数可能是多个
    let params: Vec&lt;_&gt; = func_inputs.iter().map(|i| {
        match i {
            // 提取形参的pattern
            // https://docs.rs/syn/1.0.1/syn/struct.PatType.html
            syn::FnArg::Typed(ref val) =&gt; &amp;val.pat, // pat没有办法移出val，只能借用，或者val.pat.clone()
            _ =&gt; unreachable!(&quot;it's not gonna happen.&quot;),
        }
    }).collect();

    // attr 为 untitled::run_time(args) 中的args
    let args = syn::parse_macro_input!(args as syn::AttributeArgs);
    // 提取attr的ident，此处例子只有一个attribute
    let tmp= args.get(0).unwrap();
    let attr_ident = match tmp {
        //按类型匹配 args,可以是路径,键值对等
        NestedMeta::Meta(Meta::NameValue(ref attr_ident)) =&gt; attr_ident.clone(),
        _ =&gt; unreachable!(&quot;it not gonna happen.&quot;),
    };
    //attr_ident.path 参数名 例如 #[untitled::run_time(add=1)] 中的add
    //attr_ident.lit 参数值 例如 #[untitled::run_time(add=1)] 中的 1
    let add_num= match attr_ident.lit {
        syn::Lit::Int(val)=&gt;val,
        _=&gt;unreachable!(&quot;it not num&quot;),
    };
    // 创建新的ident, 例子里这个ident的名字是time_measure
    // let attr = Ident::new(&amp;attr.to_string(), Span::call_site());
    let expanded = quote! { // 重新构建函数执行
<span class="boring">        func_vis fn #func_name #func_generics(#func_inputs) #func_output {
</span>            fn rebuild_func #func_generics(#func_inputs) #func_output #func_block
            // 要修饰函数的参数，有可能是多个参数，所以这样匹配 #(#params,) * //为vec时候合并输出
            let mut secs=rebuild_func(#(#params),*);
            use std::ops::Add;
            let addse =#add_num;
            secs=secs.add(std::time::Duration::from_secs(addse));
            secs
        }
    };
    expanded.into()
}

//使用示例
// #[untitled::run_time(add=1)]
// fn get_duration(t: u64) -&gt;std::time::Duration{
//     let secs = std::time::Duration::from_secs(t);
//     secs
// }
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ccpp笔记"><a class="header" href="#ccpp笔记">C&amp;CPP笔记</a></h1>
<ul>
<li><a href="cpp/README.html">Introduction</a></li>
<li><a href="cpp/syntax.html">语法</a></li>
<li><a href="cpp/debug.html">调试与错误</a></li>
<li><a href="cpp/stdarg.h.html">不定参数</a></li>
<li><a href="cpp/za-xiang.html">杂项</a></li>
<li><a href="cpp/zi-fu-chuan.html">字符串</a></li>
<li><a href="cpp/socket.html">网络</a></li>
<li><a href="cpp/wen-jian.html">文件</a></li>
<li><a href="cpp/jin-cheng.html">进程</a></li>
<li><a href="cpp/pthread.html">线程</a></li>
<li><a href="cpp/xin-hao.html">信号</a></li>
<li><a href="cpp/guan-dao.html">管道</a></li>
<li><a href="cpp/shi-jian.html">时间</a></li>
<li><a href="cpp/dong-tai-jia-zai-ku.html">动态加载库</a></li>
<li><a href="cpp/chang-yong-suan-fa.html">常用算法</a></li>
<li><a href="cpp/gcchun-bian-hui-bian.html">C调用汇编</a></li>
<li><a href="cpp/hui-bian-ji-cun-qi.html">汇编寄存器</a></li>
<li><a href="cpp/hui-bian-chang-yong-zhi-ling.html">汇编常用指令</a></li>
<li><a href="cpp/jin-cheng-du-xie-wen-jian-suo.html">进程读写文件锁</a></li>
<li><a href="cpp/phpzhong-jiyu-atomic-de-zi-xuan-suo-shi-xian.html">PHP中基于atomic的自旋锁实现</a></li>
<li><a href="cpp/chang-liang-zi-fu-chuan-pi-liang-ying-she.html">PHP中常量字符串批量映射</a></li>
<li><a href="cpp/tcpudpxie-yi-xiang-jie.html">TCP/UDP包示例</a></li>
<li><a href="cpp/xi-tong-diao-yong-zhong-ding-yi.html">系统函数重定义</a></li>
<li><a href="cpp/bit-op.html">加减乘除位运算</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语法"><a class="header" href="#语法">语法</a></h1>
<ol>
<li>引入文件
<ul>
<li>
<p>系统头文件 [常用头文件]</p>
<pre><code class="language-c">//C头
#include &lt;stdio.h&gt; //IO操作
#include &lt;stdlib.h&gt;  //内存分配，随机数，排序等常用函数
#include &lt;time.h&gt; //时间操作
#include &lt;stdarg.h&gt; //不定参数
#include &lt;signal.h&gt; //信号
#include &lt;setjmp.h&gt; //异常处理函数，如信号跳转点函数 sigsetjmp
#include &lt;sys/wait.h&gt; //进程结束wait waitpid 等函数
#include &lt;unistd.h&gt; //系统调用，pipe，fork，getpid，IO（read,write,close等）
#include &lt;fcntl.h&gt; //open等底层函数
#include &lt;sys/types.h&gt; //基本类型定义
#include &lt;sys/stat.h&gt; //文件状态信息
#include &lt;string.h&gt; //字符操作函数 如strcpy strlen等函数
#include &lt;sys/socket.h&gt; //网络操作函数 如：socket inet_pton listen 等函数
#include &lt;pthread.h&gt; //线程处理函数
#include &lt;ctype.h&gt; //字符处理 如 tolower toupper 等
#include &lt;assert.h&gt; //断言函数
#include &lt;errno.h&gt; //错误码定义
#include &lt;limits.h&gt; //常用数据类型最值
#include &lt;math.h&gt; //常用数学操作函数
#include &lt;wchar.h&gt; //宽字符处理，类似string.h
#include &lt;wctype.h&gt; //宽字符处理，类似ctype.h
#include &lt;complex.h&gt;　　 //复数处理
#include &lt;fenv.h&gt;　　　　//浮点环境
#include &lt;inttypes.h&gt;　　//整数格式转换
#include &lt;stdbool.h&gt;　　 //布尔环境
#include &lt;stdint.h&gt;　　　//整型环境
#include &lt;tgmath.h&gt;　　　//通用类型数学宏
//C++头
#include &lt;algorithm&gt;　　　 //STL 通用算法
#include &lt;bitset&gt;　　　　　//STL 位集容器
#include &lt;cctype&gt;         //字符处理
#include &lt;cerrno&gt; 　　　　 //定义错误码
#include &lt;cfloat&gt;　　　　 //浮点数处理
#include &lt;ciso646&gt;         //对应各种运算符的宏
#include &lt;climits&gt; 　　　　//定义各种数据类型最值的常量
#include &lt;clocale&gt; 　　　　//定义本地化函数
#include &lt;cmath&gt; 　　　　　//定义数学函数
#include &lt;complex&gt;　　　　 //复数类
#include &lt;csignal&gt;         //信号机制支持
#include &lt;csetjmp&gt;         //异常处理支持
#include &lt;cstdarg&gt;         //不定参数列表支持
#include &lt;cstddef&gt;         //常用常量
#include &lt;cstdio&gt; 　　　　 //定义输入／输出函数
#include &lt;cstdlib&gt; 　　　　//定义杂项函数及内存分配函数
#include &lt;cstring&gt; 　　　　//字符串处理
#include &lt;ctime&gt; 　　　　　//定义关于时间的函数
#include &lt;cwchar&gt; 　　　　 //宽字符处理及输入／输出
#include &lt;cwctype&gt; 　　　　//宽字符分类
#include &lt;deque&gt;　　　　　 //STL 双端队列容器
#include &lt;exception&gt;　　　 //异常处理类
#include &lt;fstream&gt; 　　　 //文件输入／输出
#include &lt;functional&gt;　　　//STL 定义运算函数（代替运算符）
#include &lt;limits&gt; 　　　　 //定义各种数据类型最值常量
#include &lt;list&gt;　　　　　　//STL 线性列表容器
#include &lt;locale&gt;         //本地化特定信息
#include &lt;map&gt;　　　　　　 //STL 映射容器
#include &lt;memory&gt;         //STL通过分配器进行的内存分配
#include &lt;new&gt;            //动态内存分配
#include &lt;numeric&gt;         //STL常用的数字操作
#include &lt;iomanip&gt; 　　　 //参数化输入／输出
#include &lt;ios&gt;　　　　　　 //基本输入／输出支持
#include &lt;iosfwd&gt;　　　　　//输入／输出系统使用的前置声明
#include &lt;iostream&gt; 　　　//数据流输入／输出
#include &lt;istream&gt;　　　　 //基本输入流
#include &lt;iterator&gt;        //STL迭代器
#include &lt;ostream&gt;　　　　 //基本输出流
#include &lt;queue&gt;　　　　　 //STL 队列容器
#include &lt;set&gt;　　　　　　 //STL 集合容器
#include &lt;sstream&gt;　　　　 //基于字符串的流 stringstream等
#include &lt;stack&gt;　　　　　 //STL 堆栈容器
#include &lt;stdexcept&gt;　　　 //标准异常类
#include &lt;streambuf&gt;　　　 //底层输入／输出支持
#include &lt;string&gt;　　　　　//字符串类
#include &lt;typeinfo&gt;        //运行期间类型信息
#include &lt;utility&gt;　　　　 //STL 通用模板类
#include &lt;valarray&gt;        //对包含值的数组的操作
#include &lt;vector&gt;　　　　　//STL 动态数组容器
</code></pre>
</li>
<li>
<p>自定义头文件</p>
<pre><code class="language-c">#include &lt;comst.h&gt;
#include &lt;comst.hpp&gt;
</code></pre>
</li>
</ul>
</li>
<li>宏 常量 变量
<ul>
<li>
<p>宏</p>
<pre><code class="language-c">// 
#ifndef PI
#define S(a,b) a+b;/*定义宏*/
#endif
#define a1(b) #b // 一个#号说明b被当成一个字符串 结果为 &quot;b&quot;
#define a2(b) s##b //两个#号表示b被当成字符串且与字符s链接
#define a3()  do{ }while(0) //复杂定义使用,保证任何场合都适用
</code></pre>
</li>
<li>
<p>常量</p>
<pre><code class="language-c">const int v1 = 100;定义类型常量
</code></pre>
</li>
<li>
<p>变量定义问题</p>
<pre><code class="language-c">register int i;//i会放入寄存器
////////////////////////////////////////////////////////////////
//struct 的声明可以省略typedef,注意事项:
//内存对齐规则
//结构体大小必须是结构体中最大的类型的倍数
//结构成员的起始位置必须是该类型(基本数据类型)的大小的倍数
//结构体省内存方法
//成员小的放置于前面,相同大小的尽量放置于一块,成倍数的放置于相邻位置
////////////////////////////////////////////////////////////////
//结构体1
struct struct1
{
int day;
};
//
//结构体2
typedef struct{
char c;
} struct2;
//struct2 *p;
//p=(struct2 *)malloc(sizeof(struct2));//动态分配内存
////////////////////////////////////////////////////////////////
//联合1
union var{  
long int l;  
int i;  
};
//
//联合2
typedef union{
char c;
int a;
} var1;
////////////////////////////////////////////////////////////////
//enum 是整形,且不会有类型验证
enum e1{HI}; 
enum e2{GOOD};
enum e1 a=HI;
enum e2 b=GOOD;
//a==b true
////////////////////////////////////////////////////////////////
//函数指针
typedef void(*fn)(void *m);
void hi(void *m){
printf(&quot;%s&quot;,&quot;hi&quot;);
};
fn b=&amp;hi;
////////////////////////////////////////////////////////////////
//空指针 void*
void* k=(void *)(0);
////////////////////////////////////////////////////////////////
//数组长度
int a[]={1,2};//a 为数组名，非指针，但数组名有类指针功能
int len=sizeof(a)/sizeof(a[0]);
</code></pre>
</li>
<li>
<p>自动变量类型</p>
<pre><code class="language-c">////////////GUNC///////////////
int a=1;
typeof(a) b=a;
printf(&quot;%d&quot;,b);
//////////C11////////////
int a=1;
auto b=a;
printf(&quot;%d&quot;,b);
</code></pre>
</li>
<li>
<p>变量作用域和优先级</p>
<pre><code class="language-c">//文件内变量，文件外不可见
static int w1=100;
//C++中，局部变量存在与{}中
bool a=true;
while(a){
int i=1;
a=false;
}
cout &lt;&lt; i;//未定义
for(int i=1;i&lt;2;i++){}
cout&lt;&lt; i;//未定义
////////////////////////////////////////////////////////////////
//引用其他文件定义，即其他文件有定义 int a;
extern int a;
////////////////////////////////////////////////////////////////
//++问题
int t1 = 5, t2 = 7;
t1+++t2;//12 t1++ +t2 ++后为执行后加 ++前为执行前加
</code></pre>
</li>
<li>
<p>变量引用 1. int&amp; 表示一个引用,引用看着操作对象的别名 2. 引用跟引用对象的内存地址相同</p>
<pre><code class="language-c">int k=10;
int&amp;rk=k;
//&amp;k==&amp;rk
</code></pre>
<ol>
<li>
<p>引用定义时初始化，创建时必须绑定操作对象</p>
<pre><code class="language-c">int k=10;
//int&amp;b;
//b=k;wrong
int&amp; b=k;
</code></pre>
</li>
<li>
<p>形参引用为传引用</p>
<pre><code class="language-c">int a(int &amp;b){
return 1;
}
int main(){
int b=2;
a(b);
}
</code></pre>
</li>
<li>
<p>返回为以引用时候，可以把返回值赋值</p>
<pre><code class="language-c">struct a{
int id;
}
a va;
a &amp; fn(){
return va;
}
int main(){
fn().id=10;
return 0;
}
</code></pre>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>字符数字转换</p>
<pre><code class="language-c">/////////////////////////数字转字符//////////////////////////////
//-----------------------------C-------------------------------
//C方式1 标准方式
#include &lt;stdio.h&gt;
int n=1000;
char ns[5];
snprintf(ns,5,&quot;%d&quot;,n);
printf(&quot;%s&quot;,ns);
//
//C方式2,浮点数
double value= 86.789e5;
int dec, sign;
int ndig = 5;
//参数:浮点数,要转换的位数,小数点的位置(返回),正或负数(返回)
//返回:连续的字符串,无小数点
char *p = ecvt(value,ndig,&amp;dec,&amp;sign);
//跟上面一样,但结果会四舍五入
char *p = fcvt(value,ndig,&amp;dec,&amp;sign);
//
//C方式3
string[10];
//整数,存储的字符串,整数进制(2,10等) 后面没有\0结束
itoa(int, string*, 10);
//
//-------------------------C++-------------------------------
//C++方式1
#include &lt;string&gt;
string sinta(&quot;1234&quot;);
const char *tchar=sinta.c_str();
//
//C++方式2
#include &lt;string&gt;
#include &lt;sstream&gt;
int inta=12345;
stringstream tsinta;
tsinta &lt;&lt; inta;
string sinta =tsinta.str();
//或者，注意流的 &lt;&lt; &gt;&gt; 重载
string sinta; 
tsinta &gt;&gt; sinta;
//
/////////////////////////字符转数字//////////////////////////////
//C方式 1
#include &lt;stdlib.h&gt;
float fa=atof(&quot;10.1&quot;);//字符串转浮点
int ia=atoi(&quot;10&quot;);//字符串转整形
long int la=atol(&quot;10&quot;);//字符串转整形
//
//C方式 2 标准方式
#include &lt;stdio.h&gt;
int a;
sscanf(&quot;2006&quot;, &quot;%d&quot;, &amp;a);//字符转数值
//C++方式
#include &lt;string&gt;
#include &lt;sstream&gt;
int a;
string str = &quot;-1024&quot;;
istringstream issInt(str);
issInt &gt;&gt; a;
</code></pre>
</li>
</ul>
<ol>
<li>函数 类
<ul>
<li>函数 [容许重名]
<ol>
<li>先根据函数名查找</li>
<li>根据类型加数量匹配</li>
<li>模糊匹配，类型转换</li>
</ol>
</li>
</ul>
</li>
</ol>
<pre><code class="language-c">  //头文件
  typedef void(*fnp)();
  void hi();
  fnp fn();
  //实现
  void hi(){
   printf(&quot;%s&quot;,&quot;hi&quot;);
  };
  fnp fn(fnp){
   return hi;
  }
  //使用
  fnp c=fn(hi);
  c();
  ///////////////////////////模板/////////////////////////
  //头文件
  template&lt;typename T&gt; void swap(T&amp; t1, T&amp; t2);
  //实现
  template&lt;typename  T&gt; void swap(T&amp; t1, T&amp; t2) {
     T tmpT;
     tmpT = t1;
     t1 = t2;
     t2 = tmpT;
  }
  //使用
  int t1=1;
  int t2=2;
  swap&lt;int&gt;(t1,t2);
</code></pre>
<ul>
<li>
<p>类 1. 基本定义</p>
<pre><code class="language-c">//头文件 hpp
struct test{
public:
   test();
   int number1;
   static int number2;
   void fn1();
   static void fn2();
   ~test();
   inline void inlinefn(){
     //inline 必须写到头文件中
   };
protected:
   char* number3;
   static char number4[10];
   void fn3();
   static void fn4();
private:
   int number5;
   static char* number6;
   void fn5();
   static void fn6();
};
//实现
int test::number2 = 1;
char test::number4[10]=&quot;init char&quot;;
char* test::number6=NULL;
test::test():number1(10),number5(10){//初始化成员值
//构造函数
};
void test::~test(){
//析构函数
}
void test::fn1(){
 printf(&quot;%d&quot;,this-&gt;number5);
}
void test::fn2(){
}
void test::fn3(){
}
void test::fn4(){
}
void test::fn5(){
}
void test::fn6(){
}
</code></pre>
<ol>
<li>
<p>修饰符</p>
<pre><code class="language-c">void mb(){
}
class objvar{
public:
objvar(int a,int b){
}
}
class obj{
public:
obj (const obj&amp; objvar){
//拷贝构造函数,一般有内存拷贝时实现
//声明时：obj t=varobj 或 obj t(varobj) 调用
//动态创建：obj* t=new obj(varobj);
//参数传递：void test(obj t){} 参数调用时
}
obj():a(10),b(10),ob(1,2){//构造函数 初始化 成员变量
//一定会执行
}
obj(int a,int b=10){
}
objvar ob;
int a;
void ma(){
mb();//=this-&gt;mb();
::mb();//使用全局函数
return a+b;//= this-&gt;a+this-&gt;b;
}
virtual ～obj(){//加上virtual 有利于释放资源
//free res
}
protected:
int b;
virtual void mb(){}
private:
int c;
}
strcut tobj{//抽象类
public:
virtual void vmb(int&amp; b)=0;//纯虚函数
}
struct cobj : public obj,public tobj{
//public private protected 继承方式
//支持多重继承
public:
cobj(){
obj::mb();//call parent method
}
～cobj(){
//free res
}
void vmb(int&amp; b){
//实现纯虚函数
}
protected:
void mb(){
//当子类对象转为父类指针调用时候
//virtual 函数会调用此方法，否则调用父方法
}
}
int main(){
int b(10); // int b=10;
int t(b);//= int t=b;
obj a(10,20);
obj*pa=new a(10,30);
delete pa;
int*pb= new int[1024];//连续的对象申请
delete [] pb;
return 0;
}
</code></pre>
</li>
<li>
<p>操作符重载</p>
<pre><code class="language-c">class a{
public:
int t[10];
a operator +(const a&amp; avar);//+-* /
//包含多个元素，方便操作,返回引用方便操作左值
int&amp; operator [](int index);
//比较对象，avar可以是非class a
bool operator ==(const a&amp; avar);
//类型转换
operator int();
operator const char*();
//输入输出
a&amp; operator &lt;&lt;(int b);//输出
//privae ~~
private:
string a(&quot;aaa&quot;);
}
//对class a的+操作进行重载
//实现 operator+
a::operator+(const a&amp; var){
//code~~
}
//实现 operator[]
int&amp; a::operator[](int index){
return t[index];
}
//实现 operator==
bool a::operator ==(const a&amp; avar){
return true;
}
//实现 operator type
a::operator int(){
return 1;
}
a::operator const char*(){
return a.c_char();
}
//实现 operator &lt;&lt;
a&amp; a::operator&lt;&lt;(int a){//输出
printf(&quot;%d&quot;,a);
return *this;
}
//全局操作符重载
//全局操作符重载 对全局的+操作进行重载
a operator+(const a&amp; vara,const a&amp; varb ){
//code ~~
}
//两种都存在时候，会调用类操作符
int main(){
a vara;
a varb;
vara+varb;//operator +
vara[1];//operator []
vara==varb;//operator ==
int t =(int)vara;//operator ()
varb &lt;&lt;1;//operator &lt;&lt;
return 0;
}
</code></pre>
</li>
<li>
<p>内部类</p>
<pre><code class="language-c">class a{
public:
class b{
public:
void t();
}
}
//
void a::b::t(){
printf(&quot;out&quot;);
}
int main(){
new a::b();
}
</code></pre>
</li>
<li>
<p>模板类</p>
<pre><code class="language-c">//头文件
template &lt;class T&gt;class ttest{
public:
ttest();
~ttest();
void sett(T t);
T gett();
private:
T *m_pT;
};
//实现
template &lt;class  T&gt;  ttest&lt;T&gt;::ttest(){
m_pT = new T[1];
}
template &lt;class T&gt;  ttest&lt;T&gt;::~ttest() {
delete [] m_pT ;
}
template &lt;class T&gt; void ttest&lt;T&gt;::sett(T t) {
m_pT[0] = t;
}
template &lt;class T&gt; T ttest&lt;T&gt;::gett() {
T t = m_pT[0];
return t;
}
//使用
ttest&lt;int&gt; tvar;
tvar.sett(1);
printf(&quot;%d&quot;,tvar.gett());
</code></pre>
</li>
<li>
<p>类函数指针</p>
<pre><code class="language-c">//头文件
class ru_m {
public:
ru_m();
typedef int (ru_m::*p)();
p get_m();
int show();
};
//实现
int ru_m::show(){
return 10000;
}
ru_m::p ru_m::get_m(){
ru_m::p vc;
//不能是this-&gt;show c++ 中对象成员函数为偏移非指针
vc=&amp;ru_m::show;
return vc;
}
//使用
int main()
{
ru_m r;
ru_m::p p=r.get_m();
printf(&quot;%d&quot;,(r.*p)());
return 0;
}
</code></pre>
</li>
<li>
<p>模板关键字typename和class</p>
<blockquote>
<ol>
<li>
<p>模板定义语法中关键字class与typename的作用完全一样。</p>
</li>
<li>
<p>除class和typename外还可以用其他类型定义模板,如以下</p>
<pre><code class="language-c">//头文件
template&lt;typename T,int MAX&gt; void testtemplate(T t1);
//实现
template&lt;typename  T,int MAX&gt; void testtemplate(T t1) {
T b[MAX];
for(T i=MAX;i&gt;0;i--){
b[i]=t1;
printf(&quot;%d&quot;,b[i]);
}
}
//使用
int t1=1;
testtemplate&lt;int,10&gt;(t1);
</code></pre>
</li>
</ol>
</blockquote>
</li>
</ol>
</li>
</ul>
<ol>
<li>
<p>名字空间</p>
<pre><code class="language-cpp">namespace myname{
class a{}
}
namespace myname1{
class a{}
}
using myname1::a;//单个
using namespace std;//全部
int main(){
myname::a avar myname::a;
a bvar a;
cout &lt;&lt;&quot;hi&quot;;
}
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调试与错误"><a class="header" href="#调试与错误">调试与错误</a></h1>
<ol>
<li>
<p>有定义,无实现错误:(C/C++混编出现此错,在头文件(*.h)添加extern “C”{})</p>
<blockquote>
<p>undefined reference to ‘<em>*</em>’;</p>
<pre><code class="language-c">int a();
a();
</code></pre>
</blockquote>
</li>
<li>
<p>函数未实现,被调用:</p>
<blockquote>
<p>is used uninitialized in this function **</p>
<pre><code class="language-c">typedef void (*b)();
b a;
a();
</code></pre>
</blockquote>
</li>
<li>
<p>函数未在main之前声明.</p>
<blockquote>
<p>error: conflicting types for *</p>
</blockquote>
</li>
<li>
<p>参数传递问题</p>
<blockquote>
<p>函数参数传递指针时,函数为为指针的拷贝 所以要修改指针时,需要传递指针的指针</p>
</blockquote>
</li>
<li>
<p>编译问题</p>
<blockquote>
<p>注意 GCC 会根据编译文件的文件名决定使用C++还是C</p>
</blockquote>
<ul>
<li>
<p>GCC 编译生成汇编</p>
<blockquote>
<p>gcc -S cfile</p>
</blockquote>
</li>
<li>
<p>GCC 编译不连接文件</p>
<blockquote>
<p>gcc -c cfile</p>
</blockquote>
</li>
<li>
<p>GCC 编译生成优化汇编</p>
<blockquote>
<p>gcc -O2 -S cfile</p>
</blockquote>
</li>
<li>
<p>.o 文件反编译</p>
<blockquote>
<p>objdump -d ofile.o</p>
</blockquote>
</li>
<li>
<p>GDB 调试选项</p>
<blockquote>
<p>gcc -g cfile</p>
</blockquote>
</li>
<li>
<p>GCC 生成库</p>
<blockquote>
<p>gcc -shared b.cpp</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>CDT 控制台问题</p>
<blockquote>
<p>-mwindows 编译参数加表示无控制台 -mconsole 表示控制台程序 默认不加,两个都有…</p>
</blockquote>
</li>
<li>
<p>动态内存问题</p>
<blockquote>
<p>所有一般需要大内存的时候会使用malloc或者calloc来得到堆区内存 有时候在函数内返回一个指针什么的,使用malloc,别返回栈区的指针</p>
<p>除了编译期可以知道字符串大小的,字符串指针可以不用声明长度 其他情况下字符串需声明长度</p>
<p>一般结构体,联合,整形等都是编译期就知道大小的,所以函数返回的时候返回其拷贝 但char[]虽然知道长度,但返回指针,因为其是在运行期才分配. char_,int_等指针返回为指针的拷贝.</p>
</blockquote>
</li>
<li>
<p>GDB调试</p>
<p>GDB标准库查看脚本，下载并为:~\/.gdbinit</p>
<blockquote>
<p><a href="http://www.yolinux.com/TUTORIALS/src/dbinit_stl_views-1.03.txt">http:\/\/www.yolinux.com\/TUTORIALS\/src\/dbinit_stl_views-1.03.txt</a></p>
</blockquote>
<p>运行</p>
<pre><code>gdb ./a.out
//或
gdb php -c core xx.core
</code></pre>
<p>GDB命令及注释</p>
<blockquote>
<p>gdb -tui app</p>
</blockquote>
<pre><code>r 运行
s 单步执行
n 下一行执行
si 汇编步行
ni 汇编下一行
return 强制函数返回,后面代码不运行
finish 完成函数
b 设置断点(可以函数名 行数)
info b 查看断点
bt 显示堆栈
set args 设置参数
c 继续运行
p 打印变量
pt 打印类型
x/32t x/32t 16/2进制显示32个连续内存,类似上面p
pvector 等打印STL
watch 当变量修改断点
list  查看当前运行行的上下文代码
layout src 显示源码
layout asm 显示汇编
layout regs 寄存器和汇编
layout split 汇编和源码
fs next 切换tui
disas 查看汇编
info all-registers 查看所有寄存器
set follow-fork-mode child 设置fork调试进入子进程
t 线程和进入指定线程列表
target remote ip:1234 连接到指定GDB SERVER调试 调试前使用 file *.o 文件加载源码
</code></pre>
<pre><code>//循环打印
set $i=10;
while($i--)
p $i //替换你要打印的内容
end
</code></pre>
</li>
</ol>
<blockquote>
<p>在gdb 中查看为 x/32x 0x7fffffffe3e0-0x14 其中 0x7fffffffe3e0 为rbp -0x14 为对应栈变量偏移 例如汇编:movl $0x1,-0x14(%rbp) 表示把1设置为变量(-0x14)</p>
</blockquote>
<ol>
<li>
<p>gdb 错误</p>
<p>a. Missing separate debuginfos, use: debuginfo-install 1. 需要先修改“\/etc\/yum.repos.d\/CentOS-Debuginfo.repo”文件的enable=1； 2. 使用 sudo yum install glibc 安装； 3. 使用 debuginfo-install glibc-2.12-1.132.el6.i686 安装。</p>
</li>
<li>
<p>top查看进程运行情况 1. 先用ps 得到进程ID 或用 pidof 得到 2. 在用 top -p pid 查看</p>
</li>
<li>
<p>Makefile 示例</p>
<pre><code>a : a.o b.o
      cc -o a a.o b.o
b.o : b.c b.h
      cc -c -g b.c b.h
a.o : a.c
      cc -c -g a.c b.h
clean :
      rm a a.o b.o
#makefile dome
</code></pre>
</li>
<li>
<p>core dump 文件生成[以下针对当前登录]</p>
<ol>
<li>
<p>设置core dump 文件大小</p>
<pre><code>ulimit -c unlimited
</code></pre>
</li>
<li>
<p>设置存放目录 不设置以下为 默认为执行目录</p>
<pre><code>echo &quot;/var/log/core-%e-%p-%t&quot;&gt;/proc/sys/kernel/core_pattern
//非root用户
sudo sh -c 'echo &quot;/var/log/core/%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern'
</code></pre>
</li>
<li>
<p>查看 core dump 文件</p>
<pre><code>gdb exec_file_path /var/log/core_file
</code></pre>
</li>
<li>
<p>如果没生成core文件 检查文件夹目录权限 core生成错误提示为:Segmentation fault (core dumped)</p>
</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="不定参数"><a class="header" href="#不定参数">不定参数</a></h1>
<ol>
<li>
<p>已知参数数量</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;
void argdome(int argnum,...);
int main(){ 
 //使用示例 
 argdome(2,2,1); 
 return EXIT_SUCCESS;
}
/**
* @param argnum 为参数数量
*/
void argdome(int argnum,...){ 
 va_list arglist; 
 va_start(arglist,argnum); 
 for(int i=0;i&lt;argnum;i++){ 
     //获取并转换参数类型 
     int tint=va_arg(arglist,int); 
     printf(&quot;%d\n&quot;,tint); 
 } 
 va_end(arglist);
}
</code></pre>
</li>
<li>
<p>未知参数数量</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt;
/** 
* 未知参数数量遍历
*/
void arg_p(char * start,...){ 
   va_list argp; 
   //start 为最后一个确定参数地址 
   va_start(argp,start); 
   char * para; 
   while(1){ 
       //从start后地址开始遍历剩余参数 
       para = va_arg( argp, char*); 
       if ( strcmp( para, &quot;&quot;) == 0 ) 
           break; 
       printf(&quot;%s\n&quot;,para); 
   } 
   va_end(argp);
}
/**
* 不定参数调用系统打印
*/
void arg_sprint(char * fml,...){
     va_list valist;
     va_start(valist,fml);
     vprintf(fml,valist);
     //char[100] str;//存储打印字符
     //vsprintf(str,fml,valist);
     va_end(valist);
}
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="杂项"><a class="header" href="#杂项">杂项</a></h1>
<ol>
<li>
<p>判断WIN还是LINUX</p>
<pre><code class="language-c">#if defined(WIN32) || defined(WIN64)
#include &lt;windows.h&gt;
#define sleep(n) Sleep(1000 * (n))
#else
#include &lt;unistd.h&gt;
#endif
</code></pre>
</li>
<li>
<pre><code class="language-c">int *a=calloc(3,sizeof(int));//分配连续内存空间
int *a=malloc(sizeof(int));//分配指定大小内存空间
int *a=realloc(a,sizeof(int)*3);//调整内存空间,一般大调小使用,小调大会先释放原内存重新申请
free(a);//释放内存;
exit;//正常停止
abort();//异常停止
int a=rand();//返回一个随机整数
char *a=getenv(&quot;PATH&quot;);//得到一个环境变量
putenv(&quot;VAR=VALUE&quot;);//增加环境变量
//数字字符操作 start
int a=labs(-10);//绝对值
//以下3个非标准C函数
float a=atof(&quot;10.1&quot;);//字符串转浮点
int a=atoi(&quot;10&quot;);//字符串转整形
long int a=atol(&quot;10&quot;);//字符串转整形
//浮点转字符double value= 86.789e5;int dec, sign;int ndig = 5;char *p = ecvt(value,ndig,&amp;dec,&amp;sign);//参数:浮点数,要转换的位数,小数点的位置(返回),正或负数(返回)//返回:连续的字符串,无小数点char *p = fcvt(value,ndig,&amp;dec,&amp;sign);//跟上面一样,但结果会四舍五入
//整形转字符
string[10];
itoa(int, string*, 10);//整数,存储的字符串,整数进制(2,10等) 后面没有\0结束
</code></pre>
<pre><code>lseek (int __fd, __off_t __offset, int __whence) ;//偏移
alarm (unsigned int __seconds);//闹钟函数，它可以在进程中设置一个定时器，当定时器指定的时间到时，它向进程发送SIGALRM信号
sleep (unsigned int __seconds);//秒暂停
usleep (__useconds_t __useconds);//毫秒暂停
pause (void);//暂停
chown (__const char *__file, __uid_t __owner, __gid_t __group);//更改文件权限chdir (__const char *__path);//改根目录
dup (int __fd); or dup2 (int __fd, int __fd2);//复制文件描述符
sysconf (int __name);//得到系统信息
isatty (int __fd);
link (__const char *__from, __const char *__to);
unlink (__const char *__name); //删文件
rmdir (__const char *__path);//删目录
gethostname (char *__name, size_t __len);
chroot (__const char *__path);
daemon (int __nochdir, int __noclose);
getpagesize (void);//页大小
getdtablesize (void);
sync (void);//缓存写入系统
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串-1"><a class="header" href="#字符串-1">字符串</a></h1>
<p>1.C字符串才处理</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
int main(){

    return 0;
}
</code></pre>
<p>2.C++字符串处理</p>
<pre><code>ddd
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络"><a class="header" href="#网络">网络</a></h1>
<pre><code class="language-c">#include &lt;netdb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/socket.h&gt;
int main(int arg,char *args[])
{

        struct addrinfo k,*pk;

        memset(&amp;k,0,sizeof(struct addrinfo));
        k.ai_family=AF_UNSPEC;
        k.ai_socktype=SOCK_STREAM;
        k.ai_flags=AI_PASSIVE;
        char o[100];
        int gai;
        char *r;
        if(arg&lt;=1){
                exit(0);
        }
        /*第4个参数是指向addrinfo结构指针的指针
        原理:getaddrinfo函数会根据传入的条件申请内存并创建addrinfo结构体
        在根据第4个参数传入的指针的指针,得到指向指向addrinfo的指针,并修改该值指向创建好的结构体
        因为在函数内部申请的内存,所以不需要addrinfo的时候需要调用freeaddrinfo()释放内存;*/;
        gai=getaddrinfo(args[1],&quot;80&quot;,&amp;k,&amp;pk);
        if(gai!=0){
                printf(&quot;error:%s&quot;,gai_strerror(gai));
                exit(0);
        }
        printf(&quot;domain:%s\n&quot;,args[1]);
        void * sockaddr=NULL;
        while(pk){
                switch(pk-&gt;ai_family){
                        case AF_INET:
                                sockaddr=&amp;((struct sockaddr_in *)pk-&gt;ai_addr)-&gt;sin_addr;//sockaddr_in.sin_addr 是结构体 ,不是结构体指针
                                break;
                        case AF_INET6:
                                sockaddr=&amp;((struct sockaddr_in6*)pk-&gt;ai_addr)-&gt;sin6_addr;//sockaddr_in.sin6_addr 是结构体 ,不是结构体指针
                                break;
                }
                if(sockaddr){
                        inet_ntop(pk-&gt;ai_family,sockaddr,o,100);//第2个参数需要的是sockaddr指针,不是结构体
                        if(r!=NULL){
                                printf(&quot;ip address:%s &amp; ip type:%d\n&quot;,o,(pk-&gt;ai_family==AF_INET)?4:6);
                        }

                }
                sockaddr=NULL;
                pk=pk-&gt;ai_next;
        }

        freeaddrinfo(pk);
}
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netinet/in.h&gt;

#define LEN 100
void str_to(int cs,struct sockaddr * addr,int addr_len){
        char a[LEN]=&quot;aaaaa\n&quot;;
        //read(cs,a,LEN);
        printf(&quot;%s&quot;,a);
        int i=1000;
        for(;i&gt;0;i--){
                write(cs,a,strlen(a));
                sleep(1);
        }
}

void sigpro(int *sig){
        pid_t t;
        while((t=waitpid(-1,NULL,WNOHANG))&gt;0){
                printf(&quot;c:%d\n&quot;,t);
        }
}

int main()
{

        signal(SIGCHLD,&amp;sigpro);
        int s,cs;
        s=socket(AF_INET,SOCK_STREAM,0);
        struct sockaddr_in add,cadd;
        memset(&amp;add,0,sizeof(add));
        memset(&amp;add,0,sizeof(cadd));
        add.sin_family=AF_INET;
        add.sin_port=htons(8012);
        inet_pton(AF_INET ,&quot;127.0.0.1&quot;, &amp;add.sin_addr);//sockaddr_in.sin_addr 是结构体 ,不是结构体指针
        bind(s,(struct sockaddr*)&amp;add,sizeof(add));
        listen(s,5);
        while(1){
                int clen;
                cs=accept(s,(struct sockaddr*)&amp;cadd,&amp;clen);
                pid_t t;
                t=fork();
                if(t==0){
                        str_to(cs,(struct sockaddr *)&amp;cadd,clen);
　　　　　　　　　　　　　　close(cs);
                        exit(1);
                }else{
　　　　　　　　　　close(cs);
　　　　　　　　}
        }
        return 1;
}
</code></pre>
<pre><code class="language-c">struct pollfd fds[CMAX];

        int in= fileno(stdin);
        int out= fileno(stdout);

        fds[0].fd=in;
        fds[0].events=POLLIN;// 可以多个事件 POLLIN|POLLOUT

        char a[100];
        memset(a,0,100);

        fds[1].fd=out;
        fds[1].events=POLLOUT;

        FILE *f;
        f=fopen(&quot;./txt&quot;,&quot;a&quot;);

　　　　enum {
　　　　　　SN,
　　　　　　SB
　　　　} S;
　　　　S=SN;
        while(1){
　　　　　　if(S==SB)
　　　　　　　　break;
                if( poll(fds,CMAX,0)&gt;0){
                        int i=0;
                        for(;i&lt;CMAX;i++){
                                if(fds[i].revents==POLLIN){//判断返回事件
                                        read(in,a,100);

                                        if(a[0]=='q'){
                                                printf(&quot;%s&quot;,&quot;fasdfas&quot;);

　　　　　　　　　　　　　　　　　　　　　　　　　　　　S=SB;

                                        }

                                        printf(&quot;in:%s&quot;,a);
                                        fwrite(a, strlen(a), 1, f);
                                }
                        }
                }

        }    
 fclose(f);
        return EXIT_SUCCESS;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文件"><a class="header" href="#文件">文件</a></h1>
<ol>
<li>
<p>修改句柄阻塞或非阻塞</p>
<pre><code class="language-c">int fd_set_blocked(int fd, int blocked) /* {{{ */
{
 int flags = fcntl(fd, F_GETFL);

 if (flags &lt; 0) {
     return -1;
 }

 if (blocked) {
     flags &amp;= ~O_NONBLOCK;
 } else {
     flags |= O_NONBLOCK;
 }
 return fcntl(fd, F_SETFL, flags);
}
</code></pre>
</li>
<li>
<p>C标准文件操作</p>
<ol>
<li>
<p>计算文件大小</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int fsize(const char * filename);
int main(){ 
 //使用示例 
 printf(&quot;%d&quot;,fsize(&quot;main.cpp&quot;)); 
 return EXIT_SUCCESS;
}
/**
* 计算文件大小
* @param char * filename 文件名
*/
int fsize(const char * filename){ 
 FILE* f=fopen(filename,&quot;r&quot;); 
 int filelen; 
 fseek(f,0,SEEK_END); //文件指针移到末尾 
 filelen=ftell(f); //获得文件当前指针位置，即为文件长 
 fclose(f); 
 return filelen;
}
</code></pre>
</li>
<li>
<p>读取文件成字符串:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
/**
* 读取文件内容
*/
char * file_get_contents(const char* file){ 
 FILE * fh= fopen(file,&quot;rb&quot;); 
 if(fh==NULL){ 
     printf(&quot;can’t open file no:%d&quot;,errno); 
     return NULL; 
 } 
 fseek(fh,0,SEEK_END); 
 size_t flen= ftell(fh); 
 char* filestr= (char*)malloc(flen+1);     
 memset(filestr,'\n',flen); 
 rewind(fh); 
 fread(filestr,flen,1,fh); 
 fclose(fh); 
 return filestr;
}
/**
* 写内容到文件
*/
size_t file_put_contents(const char*file,char*filestr,size_t filelen){ 
 FILE * fh=fopen(file,&quot;w&quot;); 
 if(fh==NULL){ 
     printf(&quot;can’t open file no:%d&quot;,errno); 
     return NULL; 
 } 
 size_t wlen=fwrite(filestr,filelen,1,fh); 
 fclose(fh); 
 return wlen;
}
</code></pre>
</li>
</ol>
</li>
<li>
<p>C文件函数</p>
<pre><code class="language-c">//标准IO操作 &lt;stdio.h&gt;
//
sprintf(str*,const *str,...);//其他类型转为字符串,或字符串格式化,第一个参数为转后保存指针
snprintf (char *, size_t, const char *, ...);//安全的版本,介绍见上一行
fprintf(FILE *file,const *str,...);//格式化输出到文件
printf(const *str,...);//格式化输出控制台
//变量参数列表vs_list 配套的上面三函数,va_list为strarg中,见上面的strarg.
vsprintf(str*,const *str,va_list);//其他类型转为字符串,或字符串格式化,第一个参数为转后保存指针
vasprintf(str**, fmt, *fmt,va_list);//将va_list的字符串为一个字符串,并返回该字符串的指针,onlylinux
vsnprintf (char *, size_t, const char *,va_list);//安全的版本,介绍见上一行
vfprintf(FILE *file,const *str,va_list);//格式化输出到文件
vprintf(const *str,va_list);//格式化输出控制台
sscanf (const char*, const char*, ...);//字符串转化为其他类型,参数:字符串,格式化字符,输出值指针
fscanf (FILE*, const char*, ...);//格式化文件读取
scanf (const char*, ...);//控制台输入
//
//FILE* 结构体,为文件打开指针,标准输入输出等均为该类型.(大部分平台为整形值)
FILE* f=fopen(&quot;filename&quot;,&quot;a&quot;);//打开文件
FILE* f=freopen(&quot;filename&quot;,&quot;a&quot;,stdin);//重新向打开流
//文件内操作
fseek (FILE*, long, int);//定向文件流的指针到指定位置 参数 :文件指针,偏移位置(long),位置:SEEK_SET,SEEK_CUR,SEEK_END
ftell (FILE*);//得到文件流指针的位置,long返回值
rewind (FILE*)//定向文件流指针到文件头部 = fseek(FILE*, 0, SEEK_SET);
fgetpos    (FILE*, fpos_t*);//取得文件流指针的位置
fsetpos    (FILE*, fpos_t*);//设置文件流指针的位置
feof (FILE*);//文件流是否到了文件底部
//文件内操作
fflush(FILE* f);//缓冲区的内容强制刷入文件
fclose (FILE*)//关闭流
ferror (FILE*);//操作文件发生错误时候使用
clearerr (FILE*);//清理操作文件时候发生的错误
rename(const char *,const char*);//改文件名
remove(const char *);//删除一个文件
FILE* f=tmpfile();//得到一个临时文件
tmpnam(char *tempname);//得到一个唯一的文件名
setbuf(FILE *f,char *);//设置缓存区,进行FILE IO的时候缓存文件数据保存地方
//前两参数跟上面一样,mode 为缓存模式(_IOFBF,_IOLBF,_IONBF),size 为缓存大小
int setvbuf(FILE *stream, char *buf, int mode, unsigned size); 
//以下两函数二进制安全,如直接写数组等
fread(void *,size_t 数据块大小,size_t 数据块数量,FILE* f);//读文件
fwrite(const void*, size_t 数据块大小, size_t 数据块数量, FILE*);//写文件
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进程"><a class="header" href="#进程">进程</a></h1>
<ol>
<li>
<p>后台进程</p>
<pre><code class="language-c">//当 nochdir为零时，当前目录变为根目录，否则不变；
//当 noclose为零时，标准输入、标准输出和错误输出重导向为/dev/null，也就是不输出任何信 息，否则照样输出。
//deamon()调用了fork()，如果fork成功，那么父进程就调用_exit(2)退出，所以看到的错误信息 全部是子进程产生的。如果成功函数返回0，否则返回-1并设置errno。
//int daemon(int nochdir, int noclose); 
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;limits.h&gt;
defind PATH_MAX 100
int main(int argc, char *argv[])
{
 char strCurPath[PATH_MAX];
 if(daemon(1, 1) &lt; 0)
 {
     perror(&quot;error daemon.../n&quot;);
     exit(1);
 }
 sleep(10);
 if(getcwd(strCurPath, PATH_MAX) == NULL)
 {
     perror(&quot;error getcwd&quot;);
     exit(1);
 }
 printf(&quot;%s/n&quot;, strCurPath);
 return 0;
}
</code></pre>
</li>
<li>
<p>daemon 作用类似以下代码</p>
<pre><code class="language-c">int pid;
pid=fork();
if(pid&lt;0)
exit(1);  //创建错误，退出
else if(pid&gt;0) //父进程退出
exit(0);
setsid(); //使子进程成为组长
</code></pre>
</li>
<li>
<p>处理子进程结束</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;wait.h&gt;
void sighf(int sig){
pid_t t;
//pid = -1 与 wait 一样
//pid=0 同组子进程
//pid&gt;0||pid&lt;-1 指定pid的子进程
//option WCONTINUED 作业控制 WONHANG 不阻塞返回:0 WUNTRACRD 作业控制未报告返回
while((t=waitpid(-1,NULL,WNOHANG))&gt;0){
    printf(&quot;c:%d\n&quot;,t);
}
}
int main(){
sighandler_t h=signal(SIGCHLD,sighf);
pid_t tt=fork();
if(tt==0){
    sleep(20);
    exit(0);
}
pause();
}
</code></pre>
</li>
<li>
<p>运行程序</p>
<pre><code class="language-c">//exec函数,返回为子指定程序的exit值
#include &lt;unistd.h&gt;
int execl(const char* pathname,const char * arg,.../*(char *)0*/);
int execv(const char* pathname,char * const argv[]);
int execle(const char * pathname,const char *arg,...
/*(char *)0,char * const envp[] */);
int execve(const char *pathname,char * const argv[],char * const envp[]);
int execlp(const char * filename,const char *arg,.../*(char *)0 */);
int execvp(const char * filename,char * const argv[]);
//execve 内核级调用
//execlp execvp 从环境变量找执行文件
//execl execle 指定执行文件 此!!!新的环境变量数组即成为新执行进程的环境变量!!!
//exe*系列:execve fexecve  execv execle execl execvp execlp
//第5个字符 l 表示参数列表 v 表示参数数组
//第6个字符 e 表示指定文件 p 表示从环境中找
</code></pre>
<p>5.其他</p>
</li>
</ol>
<pre><code>#进程标识符
    #include &lt;unistd.h&gt;
    1. pid_t getpid(void); 获取当前进程的ID
    2. pid_t getppid(void); 获取父进程的ID
    3. uid_t getuid(void); 获取进程实际用户ID
    4. uid_t geteuid(void); 获取进程的有效用户ID
    5. gid_t getgid(void); 获取进程的实际组ID
    6. gid_t getegid(void); 获取进程的有效组ID
    7. pid_t fork(void); 创建一个新进程
        创建进程后,两个进程谁先执行是不确定的
        IO是共享的,文件锁不会被继承,其他资源为拷贝
    8. vfork 创建一个新进程
        此函数不拷贝资源副本,且此函数保证子进程先执行

#进程退出 
    exit(0); 正常退出,清理运行环境
    _Exit(); ISO C _exit(); POSIX 函数 不清理运行环境
为正常退出 其他说明为错误退出
    abort(); 产生SIGABRT信号,系统默认处理信号来停止

#父子进程

　　wait 在 SIGCHLD  信号中处理避免阻塞问题
    #include &lt;sys/wait.h&gt;
    父进程比子进程先停止,子进程的父进程将改为init PID:1
    子进程比父进程先停止,子进程僵死Z,需要父进程处理:
    1. pid_t wait (int *statloc); 
        等待任何一个进程退出,进程阻塞
    2. pid_t waitpid(pid_t pid,int *statloc,int option);
         等待指定进程退出
         pid = -1 与 wait 一样 
         pid=0 同组子进程 
         pid&gt;0||pid&lt;-1 指定pid的子进程
         option WCONTINUED 作业控制 WONHANG 不阻塞返回:0 WUNTRACRD 作业控制未报告返回
    处理 wait函数返回
        判断statloc 值
        WIFEXITED(statloc); 子进程正常终止
        WIFSIGNALED(statloc); 子进程异常中止,以下为辅助宏:
            WTERMSIG(statloc); 获取终止子进程的信号编号
            WCOREDUMP(statloc); 判断是否产生core文件(不是所有平台都有)
        WIFSTOPPED(statloc); 子进程处于暂停状态
        WIFCONTINUED(statloc);作业控制继续    

    3. int waitid(idtype_t idtype,id_t id.siginfo *infop,int options);
        类似waitpid 功能
        idtype_t 可选值 P_PID : 指定子进程ID P_PGID :指定组进程子ID P_ALL :何以子进程
        *infop 返回子进程的状态信息
        options 可选值 WCONTINUED WEXITED WONHANG WNOWAIT WSTOPPED
    4. pid_t wait3(int &amp; statloc,int options,struct rusage &amp;rusage);
    5. pid_t wait4(pid_t pid,int *statloc,int options,struct rusage *rusage);

#竞争条件
    由于两个进程谁先执行,所以进程间要相互依赖时候,需要相互等待



#更改用户ID和组ID 无权限修改后值不变
    #include &lt;unistd.h&gt;
    1. int setuid(uid_t uid);
    2. int setgid(gid_t gid); 
    3. int seteuid(uid_t uid); 
    4. int seteuid(uid_t uid); 

    备注:
    root 或chmod u+s 修改实际用户
    root 或chmod g+s 修改实际用户组

#解析器文件:
    #include &lt;stdlib.h&gt;
    int system(const char *cmdstring);
    有调用此函数的程序禁止给root权限

#用户标识:
    #include &lt;unistd.h&gt;
    char * getlogin(void); 出错返回NULL



##进程关系
#进程时间: 子进程清0
    #include &lt;sys/times.h&gt;
    clock_t times(struct tms *buf); 填写当前CPU时间
        struct tms{
            clock_t tms_utime;
            clock_t tms_stime;
            clock_t tms_cutime;
            clock_t tms_cstime;
        };
    clock_t 为滴答数,转换秒处于系统每秒滴答数:sysconf(_SC_CLK_TCK);

#进程组
    与统一作业关联,可以接收来自同一终端的各种信号
    进程组ID默认等于其进程ID
    #include &lt;unistd.h&gt;
    pid_t getpgrp(void); 取得当前进程的进程组ID
    pid_t getpgid(pid_t pid); 获取指定进程的进程组ID 0等于getpgrp
    int setpgid(pid_t pid,pid_t pgid); 设置进程的进程组ID

#会话
    多个进程组 组成一个会话
    #include &lt;unistd.h&gt;
    pid_t setsid(void); 设置一个新会话
    pid_t getsid(pid_t pid); 获得一个会话ID


##信号
    linux:  &lt;bits/signal.h&gt; 
    maxos&amp;&amp;freebsd: &lt;sys/signal.h&gt;
    solaris: &lt;sys/iso/signal_iso.h&gt;
    #include &lt;signal.h&gt;
    子进程将继承父进程的信号处理方法
#UNIX系统信号(具体:**)
    SIGKILL 终止信号
    SIGCHLD 子进程终止向父进程发送的信号
    SIGCLD 系统V的子进程终止信号(不要用)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线程"><a class="header" href="#线程">线程</a></h1>
<pre><code>##线程 pthread

#线程概念
    进程中的所有信息在线程中都是共享的
　　 编译参数 最后加上 -lpthread
    判断是否支持线程 sysconf(_SC_THREADS)
    线程ID是pthread_t 数据类型,各个平台的结构不相同
    每个线程都有errno副本

#基本线程函数
    #include &lt;pthread.h&gt;
    pthread_t pthread_self(void); 获取本身的线程ID
    int pthread_create(pthread_t *restrict tidp,
                       const pthread_attr_t *restrict attr,
                       void *(*start_rtn)(void),void *restrict arg);
        tidp 新线程的pthread_t的指针
        attr 新线程的属性 可以传null
        start_rtn 线程处理函数
        arg 传给线程的参数 可以传null
    int pthread_equal(pthread_t *pthread1,pthread_t *pthread2);
        判断是否是同一个线程
    void pthread_exit(void *rval_ptr); 线程终止
        *rval_ptr 线程停止时候的返回状态码
    int pthread_join(pthread_t thread,void **rval_ptr); 
        等待线程结束后执行,线程必须要处于非分离状态,分离线程使用pthread_detach
    int pthread_cancel(pthread_t tid);
        取消同一进程中的指定线程,单是提出请求,进程不一定会停止
    void pthread_cleanup_push(void (*rtn)(void *),void *arg);
        当线程以下情况时执行,可以添加多个:
            当线程执行 pthread_exit ,
            被其他线程调用pthread_cancel时,
            用非0执行pthread_cleanup_pop函数时
    void pthread_cleanup_pop(intg execute);
        清理pthread_cleanup_push添加的处理函数,当0时候不执行清理函数,多个调用多次清理
    int pthread_detach(pthread_t tid);
        分离线程

#线程同步
    1.互斥量
        防止相互加锁形成死锁,加锁后其他线程加锁将阻塞
        #include &lt;pthread.h&gt;
        int pthread_mutex_init(pthread_mutex_t *restrict muter,
                               const pthread_mutexattr_t *restrict attr);
            创建一个互斥量,也可以给pthread_mutex_t赋:PTHREAD_MUTEX_INITIALIZER;
                muter 是pthread_mutex_t类型的指针 ,通常为结构体的一部分
                attr 为该互斥量的一些属性
        int pthread_mutex_destroy(pthread_mutex_t * mutex);
            销毁一个互斥量
                muter 传给创建时候的pthread_mutex_t类型的指针
        int pthread_mutex_lock(pthread_mutex_t *muter);
             给一个互斥量加锁
        int pthread_mutex_trylock(pthread_mutex_t *muter);
            检查一个互斥量是否有枷锁,不会被阻塞.可以获得锁时候返回0 否则返回 EBUSY
        int pthread_mutex_unlock(pthread_mutex_t *muter);
            给一个互斥量解锁
        示例互斥量结构
            struct dome_mutex{
                int f_count;
                pthread_mutex_t f_lock;
            }
    2.读写锁(共享-独占锁)
        当一个线程加写锁,其他所有线程对该锁加锁都阻塞
        当一个线程加读锁,其他线程都可以继续加读锁,
        当加写锁被阻塞,直到所有的读锁解锁,后面的读锁也会阻塞,防止读锁占用时间过长
        #include &lt;pthread.h&gt;
        int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
                                const pthread_rwlockattr_t *restrict attr);
            创建一个读写锁
        int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
            销毁一个读写锁
        int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
            加读 读写锁
        int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
            加写 读写锁
        int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
            解锁读或写的读写锁
        int phread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
            检查读写锁是否已经被锁为读锁,可以获得锁时候返回0 否则返回 EBUSY
        int phread_rwlock_trywrlock(prhread_rwlock_t *rwlock);
            检查读写锁是否已经被锁为写锁.可以获得锁时候返回0 否则返回 EBUSY
        示例读写锁结构
            struct dome_mutex{
                int f_count;
                pthread_rwlock_t f_lock;
            }
    3.条件变量
        条件变量需要配合互斥量使用
        #include &lt;pthread.h&gt;
        int pthread_cond_init (pthread_cond_t *restrict cond,
                               prhread_condattr_t *restrict attr);
            初始化条件变量,也可以给pthread_cond_t赋:PTHREAD_COND_INITIALIZER来初始化
        int pthread_cond_destory(pthread_coud_t *cond);
            释放条件变量
        int pthread_cond_wait(pthread_cond_t *restrict cond,
                              pthread_mutex_t *restrict mutex);
            等待条件为真返回变量
            cond 为pthread_cond_t条件变量
            mutex 为pthread_mutex_t互斥量
        int pthread_cond_timedwait(pthread_cond_t *restrict cond,
                                   pthread_mutex_t *restrict mutex,
                                   const struct timespec *restrict timeout);
            跟pthread_cond_wait功能相同,多一个超时,超时后返回ETIMEDOUT
            等待的时间结构,需要加当前时间
            struct timespec {
                time_t tv_sec;/*秒*/
                time_t tv_nsec;/*豪秒*/
            }
        int pthread_cond_signal(pthread_cond_t *cond);
            唤醒等待某个条件的某个线程,更改条件后调用 (POSIX规定跟pthread_cond_broadcast作用一样)
        int pthread_cond_broadcast(pthread_cond_t *cond);
            唤醒等待某个条件的所有线程,更改条件后调用

　　    备注:
            -&gt; 得到互斥锁 (线程1)
　　　　　　　-&gt; 设置条件变量,释放互斥锁 并等待触发 (线程1)
　　　　　　　-&gt; 得到互斥锁 (线程2)
            -&gt; 触发条件 (线程2)
            -&gt; 释放互斥锁 (线程2)
            -&gt; 触发,获得互斥锁 (线程1)
　　　　　　　-&gt; 执行 (线程1)
            -&gt; 释放互斥锁 (线程1)


##线程控制

#线程属性
    #include &lt;pthread.h&gt;
    线程属性结构pthread_attr_t 对程序是不透明的 具体参数参考:page 314 
    当不需要了解线程执行状态设置线程分离,线程执行完毕之后会自动回收分配的资源
    int pthread_attr_init(pthread_attr_t *attr);
        初始化一个线程属性
    int pthread_attr_destory(pthrad_attr_t *attr);
        销毁一个线程属性
    int pthread_attr_setdetachstate(const pthread_attr_t *restrict attr,
                                    int detachstate);
        设置线程分离分离状态 detachstate  可选值
            PTHREAD_CREATE_DETACHED 分离状态启动线程
            PTHREAD_CREATE_JOINABLE 正常状态启动进程
    int pthread_attr_getdetachstate(const pthread_attr_t *restrict attr,
                                    int *detachstate);
        获取指定线程属性的启动状态
    int pthread_attr_getstack(const pthrad_attr_t *restrict attr,
                              void **restrict stackaddr,
                              size_t *restrict stacksize);
        获取stackaddr线程属性
    int pthread_attr_setstack(cosnt pthread_attr_t (attr,
                              void *stackaddr,size_t *stacksize);
        设置stackaddr线程属性

#线程私有数据
    创建线程内全局变量

   int pthread_key_create(pthread_key_t *keyp,void(*destructor)(void*));
        创建进程的私有数据
            destructor 为当线程退出时候调用的函数指针,每个线程退出都调用
    int pthread_key_delete(pthread_key_t *keyp);
        删除进程的私有数据
    int pthread_setspecific(pthread_key_t *key,const void *pointer);
        设置KEY的数据
    void * pthread_getspecific(pthread_key_t *key);
        获取key的数据
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="信号"><a class="header" href="#信号">信号</a></h1>
<h2 id="信号-1"><a class="header" href="#信号-1">信号</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;setjmp.h&gt;
static sigjmp_buf jmpbuf;
void sighandle(int sig){
    printf(&quot;hi\n&quot;);
    fflush(stdout);
        siglongjmp(jmpbuf,1);
}
int main(){
    if(signal(SIGUSR1, sighandle) == SIG_ERR){
            perror(&quot;signal&quot;);
            return -1;
    }
    printf(&quot;start main\n&quot;);
    if(sigsetjmp(jmpbuf,1)){ //1 将移除信号屏蔽 0 不移除
            printf(&quot;return from sighandle\n&quot;);
    }
    while(1){
            pause();
    }
}
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;setjmp.h&gt;
void sighandle(int sig){
    printf(&quot;hi\n&quot;);
    fflush(stdout);
}
void sighandle1(int sig,siginfo_t *info,void *reverse)
{
    printf(&quot;hi1\n&quot;);
    fflush(stdout);
}
//通过mask 信号掩码可以控制信号的先后接受顺序
int main(){
    //SA_INTERRUPT 信号中断的系统调用不会自动重启动
    //SA_RESTART 信号中断的系统调用会自动重启,即信号处理完成时回到中断时的系统调用中
    //SA_NOCLDSTOP 当子进程停止时不产生此信号。当子进程终止时才产生此信号
    //SA_NOCLDWAIT 当调用进程的子进程终止时不创建僵尸进程 父进程在后调用wait 则阻塞，直到所有子进程都终止
    //SA_SIGINFO 可以得到产生此信号发生时的相关信息 siginfo_t
    struct sigaction sa_usr;
    sa_usr.sa_flags = SA_INTERRUPT;
    sa_usr.sa_handler = sighandle;   //信号处理函数
    sigemptyset(&amp;sa_usr.sa_mask);
    sigaction(SIGINT, &amp;sa_usr, NULL);

     struct sigaction sa_usr1;
    sa_usr1.sa_flags = SA_RESTART|SA_SIGINFO;
    sa_usr1.sa_sigaction = sighandle1;   //信号处理函数
    sigemptyset(&amp;sa_usr1.sa_mask);
    sigaction(SIGUSR1, &amp;sa_usr1, NULL);

    printf(&quot;start main\n&quot;);
    char b[100];
    scanf(&quot;%s&quot;,b);
}
</code></pre>
<h3 id="信号-2"><a class="header" href="#信号-2">信号</a></h3>
<pre><code>linux:  &lt;bits/signal.h&gt; 
maxos&amp;&amp;freebsd: &lt;sys/signal.h&gt;
solaris: &lt;sys/iso/signal_iso.h&gt;
#include &lt;signal.h&gt;
子进程将继承父进程的信号处理方法
</code></pre>
<h2 id="unix系统信号具体"><a class="header" href="#unix系统信号具体">UNIX系统信号(具体:**)</a></h2>
<pre><code>SIGKILL 终止信号
SIGCHLD 子进程终止向父进程发送的信号
SIGCLD 系统V的子进程终止信号(不要用)
</code></pre>
<h2 id="signal-函数"><a class="header" href="#signal-函数">signal 函数</a></h2>
<ol>
<li>void (_signal(int signo,void(_func)(int)))(int);</li>
<li>typeof void sigfun(int);<br />
sigfun <em>signal(int,sigfun</em> );</li>
</ol>
<h2 id="系统信号处理函数宏"><a class="header" href="#系统信号处理函数宏">系统信号处理函数(宏)</a></h2>
<pre><code>SIG_ERR
SIG_DFL 
SIG_IGN
</code></pre>
<h2 id="可重入函数"><a class="header" href="#可重入函数">可重入函数</a></h2>
<pre><code>因为无法预知程序执行情况,所以在实现信号处理函数时候,不要使用不可重入函数
</code></pre>
<h2 id="可信信号术语"><a class="header" href="#可信信号术语">可信信号术语</a></h2>
<pre><code>重复多个相同信号(未处理的时候)只保留传送一个,信号传送没有顺序
</code></pre>
<h2 id="发送信号"><a class="header" href="#发送信号">发送信号</a></h2>
<pre><code>#include &lt;signal.h&gt;
int kill (pid_t pid,int signo); 向指定进程发送信号,需要权限
    pid &gt;0 发送信号到指定进程
    pid==0 发送给自己
    pid ==-1 给所有有权限发送信号的进程发送信号
    pid &lt;0 pid的绝对值发送信号
int raise(int signo); 给自己发送信号

#include &lt;unistd.h&gt;
unsigned int alarm(unsigned int seconds); 设置计时器
    但上一个计时器没完成,在调用者复位定时器重新计时
int pause(void); 产生一个暂停信号
</code></pre>
<h2 id="信号集-作用告诉内核不可以发生该信号集的信号"><a class="header" href="#信号集-作用告诉内核不可以发生该信号集的信号">信号集 作用,告诉内核不可以发生该信号集的信号</a></h2>
<pre><code>#include &lt;signal.h&gt;
int sigemptyset(sigset_t *set); 清除所有信号
int sigfillset(sigset_t *set); 重置信号
int sigaddset(sigset_t *set,int signo); 添加信号
int sigdelset(sigset_t *set,int signo); 删除信号
int sigismember(const sigset_t *set,int signo); 检查是否有指定信号

int sigprocmask(int how,const sigset_t *restric set,sigset_t *restirc oset);
    把建立好的信号提交给内核或从内核取出当前的屏蔽信号
    oset 非空,当前进程的屏蔽信号通过oset返回
    set 非空,根据how的指示来修改当前的屏蔽信号 (对于SIGKILL SIGSTOP无效)
    how 取值: SIG_BLOCK 新加新的屏蔽信号 (并集)
              SIG_UNBLOCK 删除指定的屏蔽信号 (交集)
              SIG_SETMASK 用当前屏蔽信号代替原来的屏蔽信号
int sigpending(sigset_t *set);
    当信号被屏蔽之后,只是不传送给程序,信号在内核阻塞
    调用此程序可以获取被阻塞的这些没有处理的信号
    当屏蔽取出之后,信号将立即会被传送,相当于调用sigprocmask解除屏蔽后执行
</code></pre>
<h2 id="新信号处理函数"><a class="header" href="#新信号处理函数">新信号处理函数</a></h2>
<pre><code>#include &lt;signal.h&gt;
int sigaction(int signo,const struct sigaction *restrict act,
              struct sigaction * restrict oact);
    信号处理函数设置,可以代替signal函数
    signo 信号编号
    act 非空,修改信号处理动作
    oact 非空.返回原来的处理动作
    struct sigaction{
        void (*sa_handler)(int);/*信号处理函数*/
        sigset_t sa_mask; 
            /*发生信号处理时,将该信号添加到屏蔽信号集,必须初始化0
            返回时候恢复原信号集(为了保证未返回时候正常,需要使用siglongjmp函数),
            可以让某些信号在此信号之后触发*/
        int sa_flags;
            /*对信号处理的选项,对信号的发生的调整,
            可以多选值,用 | 连接参考page 262,表10-5*/
        void (*sa_sigaction)(int,siginfo_t *,void *);
        /*但sa_flags 为SA_SIGINFO时候用该函数处理信号
          用此函数处理信号可以得到产生此信号发生时的相关信息
          关于siginfo_t 的结构可以参考page 263*/
    }
</code></pre>
<h2 id="sigsetjmp与siglogjmp-函数"><a class="header" href="#sigsetjmp与siglogjmp-函数">sigsetjmp与siglogjmp 函数</a></h2>
<pre><code>但信号进入信号处理函数前,当前信号会被添加到信号屏蔽集里
但时候logjmp跳出该信号处理函数时候,有些系统不会将当前信号从信号屏蔽里移除
所以为了兼容,在信号处理函数里面,使用siglogjmp跳转程序
siglogjmp 还会恢复sigsetjmp保留的关键子
#include &lt;setjmp.h&gt;
int sigsetjmp(sigjmp_buf env,int savemask); 设置一个跳转点
void siglongjmp(sigjmp_buf env,int val); 跳转到指定跳转点
</code></pre>
<pre><code class="language-php">#include&lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;setjmp.h&gt;
static jmp_buf jmpbuf;
void sig_handler(int num)
{
    printf(&quot;\nrecvive the signal is %d\n&quot;, num);
    siglongjmp(jmpbuf, 2);//
}
int main()
{
    int time = 5;
    signal(SIGINT, sig_handler);
    //若savemask为非0值，则sigsetjmp在env中保存进程的当前屏蔽字,不屏蔽信号会存在多次触发问题
    //默认调用siglongjmp设置,第一次执行以下都返回0
    printf(&quot;1:%d&quot;,sigsetjmp(jmpbuf, 1/*savemask*/));
    printf(&quot;2:%d&quot;,sigsetjmp(jmpbuf, 1/*savemask*/));
    printf(&quot;3:%d&quot;,sigsetjmp(jmpbuf, 1/*savemask*/));//sigsetjmp会覆盖之前设置,所以信号处理完会跳转到这里[包含本行],返回siglongjmp设置的变量
    printf(&quot;enter to the sleep.\n&quot;);
    sleep(time);//阻塞时收到信号,如果信号处理函数中没有 siglongjmp ,信号处理完返回此处阻塞
    printf(&quot;sleep is over, main over.\n&quot;);
    exit(0);
}
</code></pre>
<h2 id="sigsuspend函数"><a class="header" href="#sigsuspend函数">sigsuspend函数</a></h2>
<pre><code>#include &lt;signal.h&gt;
int sigsuspend(const sigset_t *sigmask);
    sigmask 为提供给内核的屏蔽信号集
    该函数的作用是在接到一个信号之前将程序挂起,
    直到接到一个信号处理函数处理完后返回
    作用是防止信号冲突程序被挂起
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="管道"><a class="header" href="#管道">管道</a></h1>
<pre><code>//管道,管道适用IO操作,用于父子,或邻居进程间的通信,单通道.
int pipe_fd[2]; //存储管道指针 :0表示读管道,1表示写管道
if(pipe(pipe_fd)&lt;0)//返回值小于0说明管道创建失败
//单独管道创建没有意义,必须配合fock等进程创建函数
pid_t pid;
if((pid=fork())==0){//派生的时,会产生内存拷贝,而管道,网络连接等会拷贝一个指针副本,系统管理计数.
 //此处表示子进程
 close(pipe_fd[1]);//关闭写管道
 sleep(3);//确保父进程管道内信息
 r_num=read(pipe_fd[0],r_buf,100);
 printf( &quot;read num is %d the data read from the pipe is %d &quot;,r_num,atoi(r_buf));
 close(pipe_fd[0]);//关闭读管道
}else if(pid&gt;0){
 //此处表示父进程,父进程可以得到子进程ID
 close(pipe_fd[0]);//关闭父端的读管道
 strcpy(w_buf,&quot;111&quot;);
 if(write(pipe_fd[1],w_buf,4)!=-1)//写管道信息,等待子进程去读取 printf(&quot;parent write over &quot;); close(pipe_fd[1]);//关闭写管道
 sleep(10);//等待子进程读完数据并写出来
}
pread (int __fd, void *__buf, size_t __nbytes,__off_t __offset);//
pwrite (int __fd, __const void *__buf, size_t __n,__off_t __offset);
pipe (int __pipedes[2]);//通道
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="时间"><a class="header" href="#时间">时间</a></h1>
<ol>
<li>
<p>基本转换</p>
<pre><code class="language-c"> struct tm settm; 
 strptime(&quot;2017-07-24 11:34:01&quot;, &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;settm); 
 time_t tend =mktime (&amp;settm); 
 time_t tstart=time( NULL ); 
 //gmtime(&amp;tstart);//非本地时间
 printf(&quot;%d&quot;,difftime(tend,tstart));//时间差值 
 while(true){ 
     tstart = time( NULL ); 
     struct tm * tm1 =localtime(&amp;tstart); 
     char stime[30]; 
     strftime (stime, 30, &quot;%Y-%m-%d %H:%M:%S&quot;, tm1);
     printf(&quot;%s\n&quot;,stime); 
     fflush(stdout); 
     sleep(1); 
 }
</code></pre>
</li>
<li>
<p>常用函数</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="动态加载库"><a class="header" href="#动态加载库">动态加载库</a></h1>
<ol>
<li>创建库 b.cpp -fPIC 生成于位置无关的代码 实现不同机器共享</li>
</ol>
<pre><code class="language-c">extern &quot;C&quot;{//加上,防止进行CPP编译器编译 导致找不到
    int add(int a,int b)
    {
        return (a + b);
    }
}
</code></pre>
<blockquote>
<p>gcc -shared b.cpp -o dny.so -fPIC</p>
</blockquote>
<ol>
<li>使用库 a.c</li>
</ol>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;dlfcn.h&gt;
typedef int (*CAC_FUNC)(int, int);
int main()
{
    void *handle;
    char *error;
    CAC_FUNC cac_func = NULL;
    handle = dlopen(&quot;./dny.so&quot;, RTLD_LAZY);
    if (!handle) {
        fprintf(stderr, &quot;%s\n&quot;, dlerror());
        exit(EXIT_FAILURE);
    }
    *(void **) (&amp;cac_func) = dlsym(handle, &quot;add&quot;);
    if ((error = dlerror()) != NULL)  {
        fprintf(stderr, &quot;%s\n&quot;, error);
        exit(EXIT_FAILURE);
    }
    printf(&quot;add: %d\n&quot;, (*cac_func)(2,7));
    dlclose(handle);
    exit(EXIT_SUCCESS);
}
</code></pre>
<blockquote>
<p>gcc -o main a.c -ldl</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常用算法"><a class="header" href="#常用算法">常用算法</a></h1>
<ol>
<li>HASHTABLE</li>
</ol>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

typedef struct _hashnode{
    int val;
    char * key;
    struct _hashnode * next;
} hashnode;

//存储hash表大小
#define HASHTABLE_MAX 1000
//form php source
static inline unsigned int hashtable_hash_str(const char *arKey)
{
    register unsigned int hash = 5381;
    unsigned int nKeyLength=strlen(arKey);
    /* variant with the hash unrolled eight times */
    for (; nKeyLength &gt;= 8; nKeyLength -= 8) {
        hash = ((hash &lt;&lt; 5) + hash) + *arKey++;
        hash = ((hash &lt;&lt; 5) + hash) + *arKey++;
        hash = ((hash &lt;&lt; 5) + hash) + *arKey++;
        hash = ((hash &lt;&lt; 5) + hash) + *arKey++;
        hash = ((hash &lt;&lt; 5) + hash) + *arKey++;
        hash = ((hash &lt;&lt; 5) + hash) + *arKey++;
        hash = ((hash &lt;&lt; 5) + hash) + *arKey++;
        hash = ((hash &lt;&lt; 5) + hash) + *arKey++;
    }
    switch (nKeyLength) {
        case 7: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; /* fallthrough... */
        case 6: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; /* fallthrough... */
        case 5: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; /* fallthrough... */
        case 4: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; /* fallthrough... */
        case 3: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; /* fallthrough... */
        case 2: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; /* fallthrough... */
        case 1: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; break;
        case 0: break;
    }
    return hash;
}


hashnode * hashtable_create(){
    hashnode * hashs=(hashnode *)malloc(HASHTABLE_MAX * sizeof(hashnode *));
    memset(hashs, 0, HASHTABLE_MAX * sizeof(hashnode *));
    return hashs;
}

void hashtable_set(hashnode* hashlist[],const char * b,int val){
    unsigned int pos=hashtable_hash_str(b)%HASHTABLE_MAX;
    hashnode * hashp= hashlist[pos];
    while(hashp){
        if(strcmp(hashp-&gt;key,b)==0){
            break;
        }
        hashp=hashp-&gt;next;
    }
    if(!hashp){
        hashnode * p=(hashnode *)malloc(sizeof(hashnode));
        memset(p,0,sizeof(hashnode));
        char * ikey=(char *)malloc(sizeof(char)*(strlen(b)+1));
        strcpy(ikey,b);
        p-&gt;key=ikey;
        p-&gt;val=val;
        p-&gt;next=hashlist[pos];
        hashlist[pos]=p;
    }else{
        hashp-&gt;val=val;
    }
}

int hashtable_get(hashnode* hashlist[],const char * b,int *r){
    unsigned int pos=hashtable_hash_str(b)%HASHTABLE_MAX;
    hashnode * hashp= hashlist[pos];
    while(hashp){
        if(strcmp(hashp-&gt;key,b)==0){
            *r=hashp-&gt;val;
            return 1;
        }
        hashp=hashp-&gt;next;
    }
    return 0;
}

void hashtable_unset(hashnode* hashlist[],const char * b){
    unsigned int pos=hashtable_hash_str(b)%HASHTABLE_MAX;
    hashnode * hashp= hashlist[pos];
    hashnode * phashp=NULL;
    while(hashp){
        if(strcmp(hashp-&gt;key,b)==0){
            if(phashp)
                phashp-&gt;next=hashp-&gt;next;
            else
                hashlist[pos]=hashp-&gt;next;
            free(hashp-&gt;key);
            free(hashp);

        }
        phashp=hashp;
        hashp=hashp-&gt;next;
    }
}
void hashtable_free(hashnode* hashlist[]){
    int i=0;
    while(i&lt;HASHTABLE_MAX){
        hashnode * temp=hashlist[i];
        while(temp){
            hashnode * tt=temp-&gt;next;
            free(temp-&gt;key);
            free(temp);
            temp=tt;
        }
        i++;
    }
    hashlist=NULL;
}

int main(){
    //使用
    hashnode * ht=hashtable_create();
    hashtable_set(ht,&quot;abc&quot;,154544);
    int r=0;
    if(hashtable_get(ht,&quot;abc&quot;,&amp;r))
        printf(&quot;%d&quot;,r);
    hashtable_unset(ht,&quot;abc&quot;);
    if(hashtable_get(ht,&quot;abc&quot;,&amp;r))
        printf(&quot;%d&quot;,r);
    //释放所占内存
    hashtable_free(ht);
    return EXIT_SUCCESS;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c调用汇编"><a class="header" href="#c调用汇编">C调用汇编</a></h1>
<ol>
<li>C代码嵌入汇编</li>
</ol>
<blockquote>
<p><strong>asm</strong> 是gcc宏 <strong>volatile</strong> 表示编译器不优化指令 如下格式:</p>
</blockquote>
<p>格式:</p>
<pre><code>__asm__ __volatile__ (
    &quot;汇编指令&quot; 
    : &quot;=a&quot; (lo), &quot;=d&quot; (hi) //输出
    :&quot;d&quot;(a),&quot;m&quot;(b) //输入
    :破坏
);
</code></pre>
<p>示例(使用AT&amp;T汇编):</p>
<pre><code>//c 中&amp;a 的内存地址 跟汇编里的 %ebp 寄存器加偏移一致
//c 中函数名,函数指针(c中函数在代码段地址) 跟汇编中代码地址同理 即: %eip 可以放代码地址 之后会执行该函数
unsigned int a=1,b=2,c,d;
__asm__  __volatile__( //输入输出 %从0开始 如下 c为0 d为1 a为2 d为3
&quot;movl $11,%%eax\n&quot;
&quot;add %2,%%eax\n&quot;
&quot;add %3,%%eax\n&quot;
&quot;movl %%eax,%0\n&quot;
:&quot;=m&quot;(c),&quot;=a&quot;(d)       //输出
:&quot;d&quot;(a),&quot;m&quot;(b) //输入 为什么不所有都m呢?因为指令无法内存到内存,直接用d先赋值到寄存器可以简化操作
:&quot;%eax&quot;,&quot;%edx&quot;,&quot;memory&quot; //告诉编译器使用了那些寄存器或内存,好像可以不传.
);
//输入辅助符 如d 会扩展并添加到这段汇编的头部:
// mov -0x8014(%rbp) %eax
// mov %eax,%edx
//输出辅助符 如a 则把%eax赋值到d中
printf(&quot;%d&quot;,c);
</code></pre>
<p>辅助符: 通用寄存器</p>
<pre><code>&quot;a&quot; 将输入变量放入eax
&quot;b&quot; 将输入变量放入ebx
&quot;c&quot; 将输入变量放入ecx
&quot;d&quot; 将输入变量放入edx
&quot;s&quot; 将输入变量放入esi
&quot;d&quot; 将输入变量放入edi
&quot;q&quot; 将输入变量放入eax，ebx，ecx，edx中的一个
&quot;r&quot; 将输入变量放入通用寄存器，也就是eax，ebx，ecx，                                         edx，esi，edi中的一个
&quot;A&quot; 把eax和edx合成一个64 位的寄存器(use long longs)
</code></pre>
<p>内存</p>
<pre><code>&quot;m&quot; 内存变量
&quot;o&quot; 操作数为内存变量，但是其寻址方式是偏移量类型，也即是基址寻址，或者是基址加变址寻址
&quot;V&quot; 操作数为内存变量，但寻址方式不是偏移量类型
&quot; &quot; 操作数为内存变量，但寻址方式为自动增量
&quot;p&quot; 操作数是一个合法的内存地址（指针）
</code></pre>
<p>寄存器或内存</p>
<pre><code>&quot;g&quot; 将输入变量放入eax，ebx，ecx，edx中的一个或者作为内存变量
&quot;X&quot; 操作数可以是任何类型
</code></pre>
<p>立即数</p>
<pre><code>&quot;I&quot; 0-31之间的立即数（用于32位移位指令）
&quot;J&quot; 0-63之间的立即数（用于64位移位指令）
&quot;N&quot; 0-255之间的立即数（用于out指令）
&quot;i&quot; 立即数  
&quot;n&quot; 立即数，有些系统不支持除字以外的立即数，这些系统应该使用&quot;n&quot;而不是&quot;i&quot;
</code></pre>
<p>匹配</p>
<pre><code>&quot; 0 &quot; 表示用它限制的操作数与某个指定的操作数匹配，
&quot;1&quot; ... 也即该操作数就是指定的那个操作数，例如&quot;0&quot;
&quot;9&quot; 去描述&quot;％1&quot;操作数，那么&quot;%1&quot;引用的其实就是&quot;%0&quot;操作数，注意作为限定符字母的0－9 与指令中的&quot;％0&quot;－&quot;％9&quot;的区别，前者描述操作数，                                       后者代表操作数。
&amp; 该输出操作数不能使用过和输入操作数相同的寄存器
</code></pre>
<p>操作数类型</p>
<pre><code>&quot;=&quot; 操作数在指令中是只写的（输出操作数）  
&quot;+&quot; 操作数在指令中是读写类型的（输入输出操作数）
</code></pre>
<p>浮点数</p>
<pre><code>&quot;f&quot; 浮点寄存器
&quot;t&quot; 第一个浮点寄存器
&quot;u&quot; 第二个浮点寄存器
&quot;G&quot; 标准的80387浮点常数
 % 该操作数可以和下一个操作数交换位置                                       例如addl的两个操作数可以交换顺序                                      （当然两个操作数都不能是立即数）                       
 # 部分注释，从该字符到其后的逗号之间所有字母被忽略
 * 表示如果选用寄存器，则其后的字母被忽略
</code></pre>
<ol>
<li>C代码调用独立汇编文件</li>
</ol>
<blockquote>
<p>c文件</p>
</blockquote>
<pre><code class="language-c">//gcc n.c n.S -o n
#include &lt;stdio.h&gt;
extern int myasmfun() asm(&quot;myasmfun&quot;);
int main(){
    int a=myasmfun(11,22,34,44,55,66,77);
    printf(&quot;%d\n&quot;,a);
    return 0;
}
</code></pre>
<blockquote>
<p>AT&amp;T汇编</p>
</blockquote>
<pre><code>.globl myasmfun
#if !defined( __APPLE__ ) &amp;&amp; !defined( __FreeBSD__ )
.type  myasmfun, @function
#endif
myasmfun:

#if defined(__i386__)
    //参数: 都在栈中 pop 出来
    //返回 %eax
    push %ebp
    mov %esp,%ebp

    pop %edx
    add %edx,%eax
    pop %edx
    add %edx,%eax

    mov %ebp,%esp
    pop %ebp
    ret

#elif defined(__x86_64__)
    //参数:%edi %esi %edx %ecx %r8d %r9d 之后参数后面在栈中,pop出来
    //返回 %eax
    push %rbp
    mov %rsp,%rbp
    //sub $0x4,%rsp //函数内栈内存申请
    movl $11,%eax
    add %edi,%eax
    add %esi,%eax
    add %edx,%eax

    mov %rbp,%rsp
    pop %rbp
    ret
#endif
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="汇编寄存器"><a class="header" href="#汇编寄存器">汇编寄存器</a></h1>
<blockquote>
<p>dos debug命令</p>
</blockquote>
<p>打印内存 d<br />
修改指令 a<br />
查看指令 u<br />
修改内存 e<br />
执行指令 t 查看寄存器 r</p>
<blockquote>
<p>gdb 命令 disas 地址 显示指定位置汇编 = u i r (info reg) 显示寄存器 = r i r a 显示所有寄存器 i r rax 显示指定寄存器 x/32x 显示指定内存 = d si 执行 ni 按步执行 = t</p>
<p>通用寄存器</p>
</blockquote>
<p>a 累加 常用运算<br />
b 基址 存放地址<br />
c 计数 循环设置cx 后loop<br />
d 数据 数据传递</p>
<p>规则: 把a代替<br />
ah 高8位<br />
al 低8位<br />
ax 16位 = ahal eax 32位<br />
rax 64位</p>
<blockquote>
<p>段和偏移地址寄存器</p>
</blockquote>
<p>ss 栈段地址 sp 栈顶地址 push pop<br />
bp 函数时的栈低地址</p>
<p>ds,es 内存指针段 ds[0] 为具体的内存位置,配合下面<br />
di,si 变址指针 做偏移时用 如ds[si],es[di]</p>
<p>ip 代码指针 执行保存代码 加代码字节 后执行<br />
cs 代码段</p>
<blockquote>
<p>标记寄存器</p>
</blockquote>
<p>OF 运算溢出(1)<br />
DF 指针寄存器方向 用在 movsb 等拷贝时增加或减少,cld清除 std设置 IF 中断(1)<br />
TF 调试<br />
SF 负值(1)<br />
ZF 运算结果0(1)</p>
<ol>
<li>
<p>mov ax,1  </p>
<p>sub ax,0 相减并修改ZF  </p>
</li>
<li>
<p>mov ax,1  </p>
<p>cmp ax,ax 测试相减0修改ZF  </p>
</li>
<li>
<p>mov ax,0  </p>
<p>mov dx,1  </p>
<p>test ax,dx 测试并运算为0修改ZF</p>
</li>
</ol>
<p>AF 辅助进位(1)<br />
PF 为1位奇偶 1(偶)<br />
CF 运算进位(1)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="汇编常用指令"><a class="header" href="#汇编常用指令">汇编常用指令</a></h1>
<blockquote>
<p>AT&amp;T 与 INTEL 注意差异</p>
</blockquote>
<ol>
<li>INTEL mov eax,1 ;1 十进制 mov eax,01H ;1H 十六进制 a:mov eax,offset a;得到位置 mov rbp[-12],1</li>
<li>AT&amp;T: mov $1,%eax ;10进制 mov $0x1,%eax ;十六进制 a:mov $ab,%eax ;a标签可重复,ab 为得到之前位置 af 为之后位置 mov $1,-12(%rbp)</li>
</ol>
<blockquote>
<p>add 加</p>
</blockquote>
<pre><code>assume cs:code
code segment
    start:
        mov ax,10
        mov dx,1
        add ax,dx
        ; ax=11
code ends
end start
</code></pre>
<blockquote>
<p>sub 减</p>
</blockquote>
<pre><code>assume cs:code
code segment
    start:
        mov ax,10
        mov dx,1
        sub ax,dx
        ; ax=9
code ends
end start
</code></pre>
<blockquote>
<p>mul 乘 8_8 乘数:AL 结果:AX 16_16 乘数:Ax 结果:高AX 低DX</p>
</blockquote>
<pre><code>assume cs:CODES
CODES SEGMENT
START:
    ;8 位
    mov al,2
    mov bl,2
    mul dl
    ;结果 AX 4
    ;16 位
    mov ax,1000
    mov dx,1000
    mul dx
    ;结果 高AX E512 低DX 00C1
CODES ENDS
    END START
</code></pre>
<blockquote>
<p>div 除 除数:8(寄存器或内存) 被除:16 (AX) 结果：商(AL) 余数(AH) 除数:16(寄存器或内存) 被除:32 高16(DX) 低16(AX) 结果：商(AX) 余数(DX)</p>
</blockquote>
<pre><code>assume cs:code
code segment
    start:
        ; 16位除法 10/3
        mov ax,10
        mov dl,3
        div dl
        ; ah 余数 al 商
        ;32位除法 8800502 (86 48F6) / 6565 (19A5)
        mov dx,86H ;高16
        mov ax,48F6H ;低16
        mov bx,19A5H
        div bx
        ; 商(AX)053C 余数(DX) 0D4A
code ends
end start
</code></pre>
<blockquote>
<p>adc 进位加</p>
</blockquote>
<pre><code>// dome1: add ax,bx 结果 ax
// 等于如下　adc = ah+bh+CF位
add al,bl
adc ah,bh
// dome2: =&gt;1ef000h+201000h 结果　高位ax　低位dx
mov ax,001eh
mov dx,0f000h
add dx,1000h
adc ax,0020h
</code></pre>
<blockquote>
<p>sbb 借位减法</p>
</blockquote>
<pre><code>assume cs:CODES
CODES SEGMENT
START:
    ;20001H-10002H
    ;高 16 位AX 低16 dx
    mov ax,02H
    mov dx,1
    sub dx,2
    sbb ax,1 ; 借位 AX=AX-1-CF
    ;结果 高16 AX 0000 低16 DX FFFF
CODES ENDS
    END START
</code></pre>
<blockquote>
<p>jmp 跳转</p>
</blockquote>
<pre><code>assume cs:code
code segment
    start:
        mov cx,3
        jmp jmp1
        ;...
    jmp1:
        mov ax,1
        mov cx,1
        ;...
code ends
end start
</code></pre>
<blockquote>
<p>movsb movsw movsd 内存转移</p>
</blockquote>
<pre><code>assume cs:CODES
data segment
    dw 8 dup(0)
    db 16 dup(1)
data ends;
CODES SEGMENT
START:
    mov bx,data
    mov ds,bx
    add bx,1
    mov es,bx
    mov si,0
    mov di,0
    ;rep循环
    mov cx,16
    cld
    rep movsb
    ;上面3行等价于
    ;mov cx,16
    ;cploop:
    ;mov dl,ds:[si]
    ;mov es:[di],dl
    ;inc si
    ;inc di
    ;loop cploop
CODES ENDS
    END START
</code></pre>
<blockquote>
<p>offset 得到位置</p>
</blockquote>
<pre><code>assume cs:code
code segment
    start:
        mov bx,offset exit1
        ;lea bx,exit1 ;等价上面
        ;exit1 位置赋值到bx中
    exit1:
        mov ax,0
code ends
end start
</code></pre>
<blockquote>
<p>int 中断自定义 X86默认0000:0 -0000:03FF 为中断处理地址存储 中断地址保存规则 IP = N_4 CS = N_4+2 (N为中断号 例如INT 80H)</p>
</blockquote>
<pre><code>assume cs:CODES
CODES SEGMENT
START:

    CALL copy_new_7CH
    CALL set_new_7CH

    INT 7CH

    ;...
;===============================================
new_7CH:        MOV AX,1000H
; 自定义处理指令
                IRET
end_new_7CH:    
;===============================================
set_new_7CH:        MOV BX,0
                    MOV ES,BX
                    MOV word ptr ES:[7CH*4],7E00H
                    MOV word ptr ES:[7CH*4+2],0
end_set_new_7CH:     RET
;===============================================
copy_new_7CH:        MOV AX,0
                    MOV ES,AX
                    MOV DI,7E00H

                    MOV AX,CS
                    MOV DS,AX
                    MOV SI,OFFSET new_7CH

                    mov cx,OFFSET end_new_7CH - new_7CH
                    cld
                    rep movsb
end_copy_new_7CH:    ret
;===============================================
CODES ENDS
    END START
</code></pre>
<blockquote>
<p>call ret 函数调用 一定要做到栈平衡</p>
</blockquote>
<pre><code>assume cs:code
code segment
    start:
        mov ax,1
        mov bx,2
        sub ax,ax
        call fun1
        mov cx,10
        int 16H
    fun1:; 会push IP寄存器到栈中,在ret时候返回用,linux实现进程切换就靠这个.
        push bp
        mov bp,sp
        sub sp,016h ;这里偏移sp地址,等于为函数内变量申请内存,即局部变量
        call fun2
        ;...
        mov sp,bp ;还原sp到原位置 实现栈平衡
        pop bp
        ;假如这里push 地址,下面ret后会返回到这里push的地址中
        ret;会pop 栈数据到IP寄存器后执行
    fun2:
        push bp
        mov bp,sp
        mov ax,3
        mov bx,4
        pop bp
        ret
code ends
end start
</code></pre>
<blockquote>
<p>rdtsc CPU时间 一条读取TSC的指令，它把TSC的低32位存放在eax寄存器中，把TSC的高32位存放在edx中 (TSC指令获取CPU时间)</p>
</blockquote>
<pre><code>rdtsc
</code></pre>
<blockquote>
<p>bt bts btr btc 对二进制位操作</p>
</blockquote>
<pre><code>    ;BT 把 10000001b 的第七位复制到 CF, 得知是 1
    mov dx, 10000001b
    bt  dx, 7
    lahf
    ;47 - 01000111b (CF=1)
    ;BT 把 10000001b 的第六位复制到 CF, 得知是 0
    bt  dx, 6
    lahf
    ;86 - 10000110b (CF=0)
    ;BTS 在执行 BT 命令的同时, 把操作数的指定位置为 1
    mov dx, 10000001b
    bts dx, 6
    ;C1 - 11000001b
    ;BTR 在执行 BT 命令的同时, 把操作数的指定位置为 0
    mov dx, 10000001b
    btr dx, 7
    ;01 - 00000001b
    ;BTC 在执行 BT 命令的同时, 把操作数的指定位取反
    mov dx, 10000001b
    btc dx, 0
    ;80 - 10000000b
    btc dx, 0
    ;81 - 10000001b
</code></pre>
<blockquote>
<p>cmp,test 等条件判断</p>
</blockquote>
<pre><code>assume cs:code
code segment
    start:
        mov ax,1
        sub ax,1
        jz test1 ;zf=0 跳转
        ;...
    test1:
        mov ax,1
        cmp ax,ax ;相减只改zf位 结果丢弃
        jz test2 ;zf=0 跳转
        ;...
    test2:
        mov ax,1
        mov dx,2
        test ax,dx ;并运算为0 改zf位为0
        jz test3
        ;...
    test3:
        mov ax,0
        mov bx,0
        ;...
code ends
end start
</code></pre>
<blockquote>
<p>条件方式</p>
</blockquote>
<p><img src="cpp/.gitbook/assets/TIM%E6%88%AA%E5%9B%BE20190103164612.jpg" alt="跳转" /></p>
<blockquote>
<p>直接定制表</p>
</blockquote>
<pre><code>assume cs:CODES
;直接定制表示例
data segment ;段名 = 段地址
mydata db 16 dup(1)
mydata1 db 16 dup(0)
myoff dw offset mydata ;2个字节 存储 mydata 偏移地址 内存值: 00 00
myoff1 dw offset mydata1 ;2个字节 存储 mydata1 偏移地址 内存值:10 00
mylen dw offset mydata1 - offset mydata ;2个字节 存储 mydata 长度  内存值:10 00
mylen1 dw offset myoff - offset mydata1 ;2个字节 存储 mydata1 长度 内存值:10 00
myseg dw seg mydata ;2个字节 存储值等于 data 段地址
myseg1 dw seg mydata1 ;2个字节 存储值等于 data 段地址 可得出 seg 段内都是一样的
data ends
;代码段
CODES SEGMENT
ap db 1,2,3 ;ap 为直接定址表 非地址 ap[] 方式访问对应内存
ao: db 1,2,3 ;ao: 为标号 等于地址
START:
    mov ax,data ; 段名=段地址
    mov ds,ax
    mov es,ax
    mov di,0
    mov si,0
    ;段内部定制表,非本段内地址表 加段地址访问 如 ds:mydata[di]
    mov al,ap[di] ;得到第一个元素,赋值到al ap[di] 是cs:ap[di] 简写 AL 01
    ;段外部定制表访问
    mov ax,ds:mylen[0] ;//ax 0010
    ;通过直接定址表循环拷贝示例
    mov cx,16
    repdata:
    mov dl,ds:mydata[di] ; ds 为段地址 mydata 为段内段偏移 di 为偏移
    mov es:mydata1[si],dl
    inc si
    inc di
    loop repdata
CODES ENDS
    END START
</code></pre>
<blockquote>
<p>loop 循环指令</p>
</blockquote>
<pre><code>assume cs:code
code segment
    start:
        mov cx,3
        mov dx,1
        mov ax,0
    looptest:
        add ax,dx
        loop looptest
    ;ax=3
code ends
end start
</code></pre>
<blockquote>
<p>push pop栈指令</p>
</blockquote>
<pre><code>assume cs:code
data segment
    dw 8 dup(0)
data ends;
stack segment stack ;栈字段加这个关键字 指定为程序所用栈内存,去除编译警告.
    dw 8 dup(0);CPU的一些数据会写入栈顶后大约10个字节数据(CS IP 等),所以申请栈时候最好多16字节
stack ends;;
code segment
    start:
        mov ax,0
        mov bx,1
        test ax,bx
        jz tmp
        mov bx,data
        mov ds,bx
        mov bx,stack
        mov ss,bx
        mov ax,16
        mov sp,ax
        mov cx,8
    pushdata:
        mov ax,1122h
        push ax
        loop pushdata
        mov di,0
        mov cx,8
    popdata:
        pop dx
        mov ds:[di],dx
        add di,2
        loop popdata
        jmp tmp
    tmp:
        mov ax,2;
code ends
end start
</code></pre>
<blockquote>
<p>浮点数相关指令:</p>
</blockquote>
<p>浮点数基础:</p>
<pre><code>十进制: 221.001111
32位数: 0x435d0049 二进制文件实际存放为小端:49005d43 可通过objdump查看
    0 10000110 10111010000000001001001
63位数: 0x19ef954f 0x406ba009 (X86小端,高位在后)
    00011001111011111001010101001111 01000000011010111010000000001001
    实际数据:
    0 10000000110 1011101000000000100100011001111011111001010101001111

32位浮点:
    0 1位 符号位 
    10000110 8位 偏移位-127 所以:134-127=7
    10111010000000001001001 23位 尾数据 前面加 1. 参见下面:
    1.10111010000000001001001  实际数据:向右移动7位
    =221.00111389160156

64位浮点:
    0 1位 符号位 
    10000000110 11位 偏移位-1023 所以:1030-1023 =7 
    1011101000000000100100011001111011111001010101001111 尾数据 前面加 1. 参见下面:
    1.1011101.000000000100100011001111011111001010101001111  实际数据:向右移动7位
    =221.001111
</code></pre>
<p>st0-st8 80位浮点寄存器 xmm0-xmm15 128位浮点数寄存器 (32bit xmm0-xmm7) ymm0-ymm16 256位浮点数寄存器</p>
<blockquote>
<p>浮点数在AT&amp;T时,保存在 .rodata 端 通过偏移rip获得,跟整数不同 整数位$11这样的立即数 浮点寄存器在X86的64位机器默认使用xmm0-xmm15寄存器,且float 和double 都一样</p>
</blockquote>
<pre><code>float a=221.001111;
//汇编代码:
//movss  0xa5(%rip),%xmm0
//movss  %xmm0,-0x1c(%rbp)
double b=221.001111;
//汇编代码:
//movsd  0xa0(%rip),%xmm0
//movsd  %xmm0,-0x8(%rbp)
double n=a
//汇编代码:
cvtss2sd -0x1c(%rbp),%xmm1 ;精度提升并赋值到寄存器 精度下降指令为: cvtsd2ss
movsd  %xmm1,-0x10(%rbp)
</code></pre>
<blockquote>
<p>addsd 双精度加指令,规则:add sd 双精度 ss 单精度 其他指令类似</p>
<pre><code>cvtss2sd -0x14(%rbp),%xmm0
movsd  %xmm0,-0x8(%rbp)
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进程读写文件锁"><a class="header" href="#进程读写文件锁">进程读写文件锁</a></h1>
<blockquote>
<p>来源PHP源码</p>
</blockquote>
<pre><code class="language-c">#  define FCGI_LOCK(fd)                                \
    do {                                            \
        struct flock lock;                            \
        lock.l_type = F_WRLCK;                        \
        lock.l_start = 0;                            \
        lock.l_whence = SEEK_SET;                    \
        lock.l_len = 0;                                \
        if (fcntl(fd, F_SETLKW, &amp;lock) != -1) {        \
            break;                                    \
        } else if (errno != EINTR || in_shutdown) {    \
            return -1;                                \
        }                                            \
    } while (1)

#  define FCGI_UNLOCK(fd)                            \
    do {                                            \
        int orig_errno = errno;                        \
        while (1) {                                    \
            struct flock lock;                        \
            lock.l_type = F_UNLCK;                    \
            lock.l_start = 0;                        \
            lock.l_whence = SEEK_SET;                \
            lock.l_len = 0;                            \
            if (fcntl(fd, F_SETLK, &amp;lock) != -1) {    \
                break;                                \
            } else if (errno != EINTR) {            \
                return -1;                            \
            }                                        \
        }                                            \
        errno = orig_errno;                            \
    } while (0)
</code></pre>
<p>备注 error == EINTR 为中断错误.如信号 使用 fd 可以是文件.socket连接等</p>
<pre><code class="language-c">int fd=open(&quot;conftest_in&quot;, O_WRONLY|O_CREAT, 0600);
FCGI_LOCK(fd);
//file 读写操作...                                        FCGI_UNLOCK(fd);
close(fd);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="php中基于atomic的自旋锁实现"><a class="header" href="#php中基于atomic的自旋锁实现">PHP中基于atomic的自旋锁实现</a></h1>
<pre><code class="language-c">typedef volatile unsigned long atomic_t;
#define atomic_cmp_set(a,b,c) __sync_bool_compare_and_swap(a,b,c)
static inline int fpm_spinlock(atomic_t *lock, int try_once) /* {{{ */
{
    if (try_once) {
        return atomic_cmp_set(lock, 0, 1) ? 1 : 0;
    }

    for (;;) {

        if (atomic_cmp_set(lock, 0, 1)) {
            break;
        }

        sched_yield();//出让CPU使用,转移线程到运行队列的尾部
    }

    return 1;
}
/* }}} */

#define fpm_unlock(lock) lock = 0
</code></pre>
<p>进程间共享内存</p>
<pre><code class="language-c">void *fpm_shm_alloc(size_t size) /* {{{ */
{
    void *mem;

    mem = mmap(0, size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0);//进程间共享内存

#ifdef MAP_FAILED
    if (mem == MAP_FAILED) {
        return NULL;
    }
#endif

    if (!mem) {
        return NULL;
    }

    fpm_shm_size += size;
    return mem;
}
</code></pre>
<p>以下代码可以在多个进程间安全操作</p>
<pre><code class="language-c">void* mem=fpm_shm_alloc(10);
atomic_t a;
fpm_spinlock(a,0);
//mem 处理mem内容
fpm_unlock(a)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="php中常量字符串批量映射"><a class="header" href="#php中常量字符串批量映射">PHP中常量字符串批量映射</a></h1>
<pre><code class="language-c">#define ZEND_KNOWN_STRINGS(_) \
    _(ZEND_STR_FILE,                   &quot;file&quot;)
// 上面为字符串映射列表定义
typedef enum _zend_known_string_id {
#define _ZEND_STR_ID(id, str) id,
    ZEND_KNOWN_STRINGS(_ZEND_STR_ID)
#undef _ZEND_STR_ID
    ZEND_STR_LAST_KNOWN
} zend_known_string_id;
static const char *known_strings[] = {
#define _ZEND_STR_DSC(id, str) str,
        ZEND_KNOWN_STRINGS(_ZEND_STR_DSC)
#undef _ZEND_STR_DSC
        NULL
};
//遍历
for (int j = 0; j &lt; ZEND_STR_LAST_KNOWN; j++) {
    printf(&quot;%s&quot;,known_strings[j]);
}
//指定
printf(&quot;%s&quot;,known_strings[ZEND_STR_FILE]);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tcpudp包示例"><a class="header" href="#tcpudp包示例">TCP/UDP包示例</a></h1>
<blockquote>
<p>TCP 包 交换数据前会有2个客户端加1个服务器端的握手包 简称TCP3次握手</p>
</blockquote>
<p>cmd:sudo tcpdump tcp port 80 -x -s0<br />
IP 192.168.1.251.http &gt; 192.168.1.85.51335: Flags [P.], seq 1:349, ack 83, win 229, length 348: HTTP: HTTP/1.1 502 Bad Gateway<br />
0x0000: 4500 0184 10b0 4000 4006 a423 c0a8 01fb<br />
0x0010: c0a8 0155 0050 c887 ae13 3c97 3137 7fc9<br />
0x0020: 5018 00e5 8617 0000 4854 5450 2f31 2e31<br />
0x0030: 2035 3032 2042 6164 2047 6174 6577 6179<br />
0x0040: 0d0a 5365 7276 6572 3a20 6e67 696e 782f<br />
0x0050: 312e 3130 2e33 2028 5562 756e 7475 290d<br />
0x0060: 0a44 6174 653a 2054 6875 2c20 3130 204a<br />
0x0070: 616e 2032 3031 3920 3036 3a35 303a 3339<br />
0x0080: 2047 4d54 0d0a 436f 6e74 656e 742d 5479<br />
0x0090: 7065 3a20 7465 7874 2f68 746d 6c0d 0a43<br />
…</p>
<blockquote>
<p>IPv4</p>
</blockquote>
<p>4500 0184 版本4 头长5 服务类型00 包裹长度0184<br />
10b0 4000 重组标记10b0 标志 4 段偏移000<br />
4006 a423 生存时间40 协议代码06 头校验和a423<br />
c0a8 01fb 来源IP [大端] 192.168.1.251<br />
c0a8 0155 目的IP [大端] 192.168.1.85<br />
…可选选项 为空</p>
<blockquote>
<p>TCP</p>
</blockquote>
<p>0050 c887 来源端口0050=80 目标端口c887=51335<br />
ae13 3c97 数据序号<br />
3137 7fc9 确认序号<br />
5018 00e5 [1010000000110000000000011100101]偏移1010 保留000000 UAPRSF 110000 端口字段 000000011100101<br />
8617 0000 包和校验47e5 紧急指针0000<br />
… 可选选项 为空<br />
4854 5450 2f31 2e31 … 用户数据</p>
<p>cmd:sudo tcpdump udp port 8899 -x -s0<br />
IP 192.168.1.251.8899 &gt; 192.168.1.85.64450: UDP, length 7<br />
0x0000: 4500 0023 8893 4000 4011 2d96 c0a8 01fb<br />
0x0010: c0a8 0155 22c3 fbc2 000f 84c1 3131 3131<br />
0x0020: 3131 00</p>
<blockquote>
<p>IPv4 同上</p>
</blockquote>
<p>4500 0023 版本4 头长5 服务类型00 包裹长度0023<br />
8893 4000 重组标记8893 标志 4 段偏移000<br />
4011 2d96 生存时间40 协议代码11 头校验和2d96<br />
c0a8 01fb 来源IP [大端] 192.168.1.251<br />
c0a8 0155 目的IP [大端] 192.168.1.85</p>
<blockquote>
<p>UDP</p>
</blockquote>
<p>22c3 fbc2 来源端口22c3=8899 目标端口fbc2=64450<br />
000f 84c1 包长度 000f 校验和 84c1<br />
3131 3131 3131 00 用户数据</p>
<blockquote>
<p>IPv6地址格式</p>
</blockquote>
<p>2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b 3:站点前缀 1:子网 4:接口 站点前缀：通常由 ISP 或区域 Internet 注册机构分配给你 子网：您（或其他管理员）为您的站点分配的 16 位子网 接口：可以从接口的MAC地址自动配置，或使用 EUI-64 格式手动配置 备注：连续0可用::代替，示例 2001:db8:3c4d:15::1a2f:1a2b</p>
<blockquote>
<p>IPv6备注,包格式:</p>
</blockquote>
<p>4bit 版本<br />
8bit 通讯量等级<br />
20bit 流标签<br />
16bit 有效载荷长度紧随 IPv6 数据包头之后的其余数据包部分<br />
8bit 下一层协议头部 与 IPv4 协议代码字段相同的值<br />
8bit 跳数限制，每过一个路由减１,到零包被丢弃<br />
128bit 发送者的地址<br />
128bit 接收者的地址 存在可选的路由头，预定接收者不一定就是接收者<br />
…扩展头 可能为空<br />
… 用户数据</p>
<blockquote>
<p>程序抓到IP数据包后可根据以下类型对应解析:<br />
IP包代码协议:</p>
</blockquote>
<p>0 HOPOPT IPv6 逐跳选项<br />
1 ICMP Internet 控制消息<br />
2 IGMP Internet 组管理<br />
3 GGP 网关对网关<br />
4 IP IP 中的 IP（封装）<br />
5 ST 流<br />
6 TCP 传输控制<br />
7 CBT CBT<br />
8 EGP 外部网关协议<br />
9 IGP 任何专用内部网关 （Cisco 将其用于 IGRP）<br />
10 BBN-RCC-MON BBN RCC 监视<br />
11 NVP-II 网络语音协议<br />
12 PUP PUP<br />
13 ARGUS ARGUS<br />
14 EMCON EMCON<br />
15 XNET 跨网调试器<br />
16 CHAOS Chaos<br />
17 UDP 用户数据报<br />
18 MUX 多路复用<br />
19 DCN-MEAS DCN 测量子系统<br />
20 HMP 主机监视<br />
21 PRM 数据包无线测量<br />
22 XNS-IDP XEROX NS IDP<br />
23 TRUNK-1 第 1 主干<br />
24 TRUNK-2 第 2 主干<br />
25 LEAF-1 第 1 叶<br />
26 LEAF-2 第 2 叶<br />
27 RDP 可靠数据协议<br />
28 IRTP Internet 可靠事务<br />
29 ISO-TP4 ISO 传输协议第 4 类<br />
30 NETBLT 批量数据传输协议<br />
31 MFE-NSP MFE 网络服务协议<br />
32 MERIT-INP MERIT 节点间协议<br />
33 SEP 顺序交换协议<br />
34 3PC 第三方连接协议<br />
35 IDPR 域间策略路由协议<br />
36 XTP XTP<br />
37 DDP 数据报传送协议<br />
38 IDPR-CMTP IDPR 控制消息传输协议<br />
39 TP++ TP++ 传输协议<br />
40 IL IL 传输协议<br />
41 IPv6 Ipv6<br />
42 SDRP 源要求路由协议<br />
43 IPv6-Route IPv6 的路由标头<br />
44 IPv6-Frag IPv6 的片断标头<br />
45 IDRP 域间路由协议<br />
46 RSVP 保留协议<br />
47 GRE 通用路由封装<br />
48 MHRP 移动主机路由协议<br />
49 BNA BNA<br />
50 ESP IPv6 的封装安全负载<br />
51 AH IPv6 的身份验证标头<br />
52 I-NLSP 集成网络层安全性 TUBA<br />
53 SWIPE 采用加密的 IP<br />
54 NARP NBMA 地址解析协议<br />
55 MOBILE IP 移动性<br />
56 TLSP 传输层安全协议<br />
使用 Kryptonet 密钥管理<br />
57 SKIP SKIP<br />
58 IPv6-ICMP 用于 IPv6 的 ICMP<br />
59 IPv6-NoNxt 用于 IPv6 的无下一个标头<br />
60 IPv6-Opts IPv6 的目标选项<br />
61 任意主机内部协议<br />
62 CFTP CFTP<br />
63 任意本地网络<br />
64 SAT-EXPAK SATNET 与后台 EXPAK<br />
65 KRYPTOLAN Kryptolan<br />
66 RVD MIT 远程虚拟磁盘协议<br />
67 IPPC Internet Pluribus 数据包核心<br />
68 任意分布式文件系统<br />
69 SAT-MON SATNET 监视<br />
70 VISA VISA 协议<br />
71 IPCV Internet 数据包核心工具<br />
72 CPNX 计算机协议网络管理<br />
73 CPHB 计算机协议检测信号<br />
74 WSN 王安电脑网络<br />
75 PVP 数据包视频协议<br />
76 BR-SAT-MON 后台 SATNET 监视<br />
77 SUN-ND SUN ND PROTOCOL-Temporary<br />
78 WB-MON WIDEBAND 监视<br />
79 WB-EXPAK WIDEBAND EXPAK<br />
80 ISO-IP ISO Internet 协议<br />
81 VMTP VMTP<br />
82 SECURE-VMTP SECURE-VMTP<br />
83 VINES VINES<br />
84 TTP TTP<br />
85 NSFNET-IGP NSFNET-IGP<br />
86 DGP 异类网关协议<br />
87 TCF TCF<br />
88 EIGRP EIGRP<br />
89 OSPFIGP OSPFIGP<br />
90 Sprite-RPC Sprite RPC 协议<br />
91 LARP 轨迹地址解析协议<br />
92 MTP 多播传输协议<br />
93 AX.25 AX.25 帧<br />
94 IPIP IP 中的 IP 封装协议<br />
95 MICP 移动互联控制协议<br />
96 SCC-SP 信号通讯安全协议<br />
97 ETHERIP IP 中的以太网封装<br />
98 ENCAP 封装标头<br />
99 任意专用加密方案<br />
100 GMTP GMTP<br />
101 IFMP Ipsilon 流量管理协议<br />
102 PNNI IP 上的 PNNI<br />
103 PIM 独立于协议的多播<br />
104 ARIS ARIS<br />
105 SCPS SCPS<br />
106 QNX QNX<br />
107 A/N 活动网络<br />
108 IPComp IP 负载压缩协议<br />
109 SNP Sitara 网络协议<br />
110 Compaq-Peer Compaq 对等协议<br />
111 IPX-in-IP IP 中的 IPX<br />
112 VRRP 虚拟路由器冗余协议<br />
113 PGM PGM 可靠传输协议<br />
114 任意 0 跳协议<br />
115 L2TP 第二层隧道协议<br />
116 DDX D-II 数据交换 (DDX)<br />
117 IATP 交互式代理传输协议<br />
118 STP 计划传输协议<br />
119 SRP SpectraLink 无线协议<br />
120 UTI UTI<br />
121 SMP 简单邮件协议<br />
122 SM SM<br />
123 PTP 性能透明协议<br />
124 ISIS over IPv4<br />
125 FIRE<br />
126 CRTP Combat 无线传输协议<br />
127 CRUDP Combat 无线用户数据报<br />
128 SSCOPMCE<br />
129 IPLT<br />
130 SPS 安全数据包防护<br />
131 PIPE IP 中的专用 IP 封装<br />
132 SCTP 流控制传输协议<br />
133 FC 光纤通道</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="系统函数重定义"><a class="header" href="#系统函数重定义">系统函数重定义</a></h1>
<pre><code class="language-c">#define _GNU_SOURCE //RTLD_NEXT 为GUN定义 必须.编译加-ldl
#include &lt;stdio.h&gt;
#include &lt;dlfcn.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;

typedef int (*socket_pfn_t)(int domain, int type, int protocol);
static socket_pfn_t g_sys_socket_func;
int main(){
    //当前文件的socket定义为第一定义
    //默认调用的定义,这里为下面的socket函数
    socket_pfn_t g_sys_socket_func1 = (socket_pfn_t)dlsym(RTLD_DEFAULT,&quot;socket&quot;);
    //这里可以获取下一个定义,即系统定义,实现修改提供函数调动
    g_sys_socket_func = (socket_pfn_t)dlsym(RTLD_NEXT,&quot;socket&quot;);
    int sock=socket(AF_INET,SOCK_STREAM,0);
    close(sock);
}
int socket(int domain, int type, int protocol)
{
    printf(&quot;%s&quot;,&quot;hook&quot;);
    return g_sys_socket_func(domain,type,protocol);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="加减乘除位运算"><a class="header" href="#加减乘除位运算">加减乘除位运算</a></h1>
<blockquote>
<p>加法 = 异或＋(并&lt;&lt;1)</p>
</blockquote>
<pre><code class="language-c">// 递归写法
int add(int num1, int num2){
    if(num2 == 0)
        return num1;
    int sum = num1 ^ num2;
    int carry = (num1 &amp; num2) &lt;&lt; 1;//并后为1表示会进位
    return add(sum, carry);//carry&gt;0表示有进位操作，加入计算
}
​
// 迭代写法
int add(int num1, int num2){
    int sum = num1 ^ num2;
    int carry = (num1 &amp; num2) &lt;&lt; 1;  
    while(carry != 0){
        int a = sum;
        int b = carry;
        sum = a ^ b;
        carry = (a &amp; b) &lt;&lt; 1;  
    }
    return sum;
}
</code></pre>
<blockquote>
<p>减法 ＝ 加负数</p>
</blockquote>
<pre><code class="language-c">int substract(int num1, int num2){
    int subtractor = add(~num2, 1);// 先求减数的补码（取反加一）
    int result = add(num1, subtractor); // add()即上述加法运算　　
    return result ;
}
</code></pre>
<blockquote>
<p>乘法 ＝ 多个数累加</p>
</blockquote>
<pre><code class="language-c">//v1
int multiply(int a, int b){ 
    // 取绝对值　　    
    int multiplicand = a &lt; 0 ? add(~a, 1) : a;    
    int multiplier = b &lt; 0 ? add(~b , 1) : b;// 如果为负则取反加一得其补码，即正数　　    
    // 计算绝对值的乘积　　    
    int product = 0;    
    int count = 0;    
    while(count &lt; multiplier) {        
        product = add(product, multiplicand);        
        count = add(count, 1);// 这里可别用count++，都说了这里是位运算实现加法　　    
    }    
    // 确定乘积的符号　　    
    if((a ^ b) &lt; 0) {// 只考虑最高位，如果a,b异号，则异或后最高位为1；如果同号，则异或后最高位为0；　　　　        
        product = add(~product, 1);    
    }    
    return product;
}
//v2
int multiply(int a, int b) {　　
    //将乘数和被乘数都取绝对值　
    int multiplicand = a &lt; 0 ? add(~a, 1) : a; 　　
    int multiplier = b &lt; 0 ? add(~b , 1) : b;　　
    　
    //计算绝对值的乘积　　
    int product = 0;　　
    while(multiplier &gt; 0) {　　　　
        if((multiplier &amp; 0x1) &gt; 0) {// 每次考察乘数的最后一位　　　　
            product = add(product, multiplicand);　　　　
        } 　　　　
        multiplicand = multiplicand &lt;&lt; 1;// 每运算一次，被乘数要左移一位　　　　
        multiplier = multiplier &gt;&gt; 1;// 每运算一次，乘数要右移一位（可对照上图理解）　　
    } 　　
    //计算乘积的符号　　
    if((a ^ b) &lt; 0) {　　　　
        product = add(~product, 1);　　
    } 　　
    return product;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="js和其他笔记"><a class="header" href="#js和其他笔记">JS和其他笔记</a></h1>
<ul>
<li><a href="other/react-native.html">react-native</a></li>
<li><a href="other/rxjs.html">rxjs</a></li>
<li><a href="other/vim.html">vim</a></li>
<li><a href="other/css-flex.html">css flex</a></li>
<li><a href="other/docker.html">docker</a></li>
<li><a href="other/es6.html">es6</a></li>
<li><a href="other/react.html">react</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>#react-native</p>
<p>安装命令行工具</p>
<blockquote>
<p>npm i react-native-cli -g</p>
</blockquote>
<p>初始化项目</p>
<blockquote>
<p>react-native init</p>
</blockquote>
<p>安装debug版本[android]</p>
<blockquote>
<p>react-native run-android</p>
</blockquote>
<p>手动启动调试服务器[一般运行完react-native run-android会启动]</p>
<blockquote>
<p>react-native start</p>
</blockquote>
<p>签名android程序 <code>其中　release　替换你的秘钥名</code></p>
<blockquote>
<p>keytool -genkey -v -keystore shan-release.keystore -alias shan-release -keyalg RSA -keysize 2048 -validity 10000</p>
</blockquote>
<p>生成秘钥放入目录 ./android/app 中 并修改该目录下的文件:build.gradle</p>
<pre><code>signingConfigs {
    release {
        storeFile file(&quot;shan-release.keystore&quot;)
        storePassword &quot;000000&quot;
        keyAlias &quot;shan-keystore&quot;
        keyPassword &quot;000000&quot;
    }
}
 buildTypes {
    release {
        ．．．
    signingConfig signingConfigs.release
    }
}
</code></pre>
<p>在./android 目录下执行[如果不加秘钥也可以生成未签名的apk,可能无法安装]</p>
<blockquote>
<p>./gradlew assembleRelease</p>
</blockquote>
<p>重新打包可尝试清理，命令如下:</p>
<blockquote>
<p>./gradlew clean</p>
</blockquote>
<p>调试 一般8081启动时候会自动映射而React Inspector使用的8097未开启映射 开启端口映射命令,开启8097后方便调试样式</p>
<blockquote>
<p>adb reverse tcp:8081 tcp:8081</p>
</blockquote>
<blockquote>
<p>adb reverse tcp:8097 tcp:8097</p>
</blockquote>
<p>模块冲突解决
error: bundling failed: ambiguous resolution: module</p>
<blockquote>
<p>npm start – –reset-cache</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rxjs"><a class="header" href="#rxjs">rxjs</a></h1>
<blockquote>
<p>概念</p>
</blockquote>
<pre><code>Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。(操作流) 
Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。(在Observable回调函数的参数) 
Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。(回调处理) 
Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。 
Subject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。(多个监听者) 
Schedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其他。(什么时候执行)
</code></pre>
<blockquote>
<p>示例</p>
</blockquote>
<pre><code>var observable1111 = Rx.Observable.ajax({
  url: 'http://localhost:8080/'
});
var observable2 = Rx.Observable.ajax({
  url: 'http://localhost:8080/'
});
observable1111.merge(observable2)
.subscribe(x =&gt; console.log(x));
//Rx.Observable.merge()
</code></pre>
<ol>
<li>Subject 继承 Observable ,同时又实现 observer</li>
<li>所以可以 subscribe 可以 next 等.</li>
<li>因为实现 observer 所以可以继承到其他 Observable,即可以当做其他Observable 的 subscribe 的回调函数</li>
</ol>
<blockquote>
<p>默认单播,实现多播如下</p>
</blockquote>
<pre><code>    var subject = new Rx.Subject();
    subject.subscribe({
      next: (v) =&gt; console.log('observerA: ' + v)
    });
    subject.subscribe({
      next: (v) =&gt; console.log('observerB: ' + v)
    });
    var observable = Rx.Observable.from([1, 2, 3]);
    observable.subscribe(subject);//一般传函数,这里传Subject
    //如果要传递,需要传两个对象
var source = Rx.Observable.from([1, 2, 3]);
var subject = new Rx.Subject();
var multicasted = source.multicast(subject);
//var multicasted = source.multicast(subject).refCount(); //有订阅自动执行,无订阅自动关闭,不需要手动调用 connect
multicasted.subscribe({// 此函数内部调用 subject.subscribe({...})
  next: (v) =&gt; console.log('observerA: ' + v)
});
multicasted.subscribe({// 此函数内部调用 subject.subscribe({...})
  next: (v) =&gt; console.log('observerB: ' + v)
});
multicasted.connect();//此函数内部调用 source.subscribe(subject)
//multicasted等于实现连接[ConnectableObservable] Observable+Subject
</code></pre>
<blockquote>
<p>Subject 变体</p>
</blockquote>
<ol>
<li>ReplaySubject 带历史的Subject</li>
<li>AsyncSubject 执行完成时(执行 complete())发送给观察者</li>
<li>BehaviorSubject 保存了发送给消费者的最新值 类似ReplaySubject(1)</li>
</ol>
<blockquote>
<p>Scheduler 调度器[如何发送给订阅者]</p>
</blockquote>
<blockquote>
<p>observeOn() 更改调度器</p>
</blockquote>
<p>创建数据流：</p>
<pre><code>单值：of, empty, never
多值：from
定时：interval, timer
从事件创建：fromEvent
从Promise创建：fromPromise
自定义创建：create
</code></pre>
<p>转换操作：</p>
<pre><code>改变数据形态：map, mapTo, pluck
过滤一些值：filter, skip, first, last, take
时间轴上的操作：delay, timeout, throttle, debounce, audit, bufferTime
累加：reduce, scan
异常处理：throw, catch, retry, finally
条件执行：takeUntil, delayWhen, retryWhen, subscribeOn, ObserveOn
转接：switch
</code></pre>
<p>数据流进行组合：</p>
<pre><code>concat，保持原来的序列顺序连接两个数据流
merge，合并序列
race，预设条件为其中一个数据流完成
forkJoin，预设条件为所有数据流都完成
zip，取各来源数据流最后一个值合并为对象
combineLatest，取各来源数据流最后一个值合并为数组</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>#vim</p>
<p>常用插件 </p>
<blockquote>
<p>NERDTree TagList WinManager Ctags MiniBufExplorer</p>
</blockquote>
<p>打开新文件</p>
<blockquote>
<p>:open file :new file</p>
</blockquote>
<p>新窗口打开文件</p>
<blockquote>
<p>:split file</p>
</blockquote>
<p>切换编辑窗口</p>
<blockquote>
<p>Ctrl +ww [Ctrl +wj 下 Ctrl +wk 上]</p>
</blockquote>
<p>十六进制查看文件</p>
<blockquote>
<p>:%!xxd</p>
</blockquote>
<p>关闭十六进制查看文件</p>
<blockquote>
<p>:%!xxd -r</p>
</blockquote>
<p>查找下一个</p>
<blockquote>
<p>/text</p>
</blockquote>
<p>查找上一个</p>
<blockquote>
<p>?test</p>
</blockquote>
<p>高亮查找</p>
<blockquote>
<p>:set hlsearch</p>
</blockquote>
<p>逐步查找</p>
<blockquote>
<p>:set incsearch</p>
</blockquote>
<p>忽略大小写</p>
<blockquote>
<p>:set ignorecase</p>
</blockquote>
<p>替换第一个匹配[正则]</p>
<blockquote>
<p>s/old/new/</p>
</blockquote>
<p>替换所有行第一个匹配[正则]</p>
<blockquote>
<p>%s/old/new/</p>
</blockquote>
<p>指定函数匹配</p>
<blockquote>
<p>:1,$ /old/new/</p>
</blockquote>
<p>移动到文件头行</p>
<blockquote>
<p>[[</p>
</blockquote>
<p>移动到文件尾行</p>
<blockquote>
<p>]]
[{ – 转到上一个位于第一列的“{“
}] – 转到下一个位于第一列的“{“</p>
</blockquote>
<p>撤销</p>
<blockquote>
<p>u</p>
</blockquote>
<p>重做</p>
<blockquote>
<p>Ctrl+r</p>
</blockquote>
<p>删除行</p>
<blockquote>
<p>dd</p>
</blockquote>
<p>删除指定行</p>
<blockquote>
<p>:1,$d</p>
</blockquote>
<p>复制指定行到指定行之后</p>
<blockquote>
<p>:1,3 co 5</p>
</blockquote>
<p>移动指定行到指定行之后</p>
<blockquote>
<p>:1,3 m 5</p>
</blockquote>
<p>拷贝行</p>
<blockquote>
<p>yy</p>
</blockquote>
<p>粘贴</p>
<blockquote>
<p>p</p>
</blockquote>
<p>剪切</p>
<blockquote>
<p>x</p>
</blockquote>
<p>进入查看模式</p>
<blockquote>
<p>v</p>
</blockquote>
<p>重新打开</p>
<blockquote>
<p>:e!</p>
</blockquote>
<p>保持并关闭</p>
<blockquote>
<p>x</p>
</blockquote>
<p>执行命令</p>
<blockquote>
<p>:!command</p>
</blockquote>
<p>显示非打印字符</p>
<blockquote>
<p>:set list</p>
</blockquote>
<p>TAB缩进</p>
<blockquote>
<p>&lt; 和 &gt;</p>
</blockquote>
<p>自动缩进当前行</p>
<blockquote>
<p>==</p>
</blockquote>
<p>命令历史</p>
<blockquote>
<p>q:<code>选中回车执行</code></p>
</blockquote>
<p>设置窗口宽度</p>
<blockquote>
<p>:resize +100 :resize -100</p>
</blockquote>
<p>设置窗口宽度</p>
<blockquote>
<p>:vertical resize +100</p>
</blockquote>
<p>TAB操作 新标签打开</p>
<blockquote>
<p>:tabe</p>
</blockquote>
<p>标签关闭</p>
<blockquote>
<p>:tabc</p>
</blockquote>
<p>查看所有TAB</p>
<blockquote>
<p>:tabs</p>
</blockquote>
<p>关闭其他TAB</p>
<blockquote>
<p>:tabo</p>
</blockquote>
<p>进入上一个TAB</p>
<blockquote>
<p>:tabp</p>
</blockquote>
<p>进入下一个TAB</p>
<blockquote>
<p>:tabn</p>
</blockquote>
<p>编译</p>
<blockquote>
<p>:make</p>
</blockquote>
<p>查看编译错误</p>
<blockquote>
<p>:cc </p>
</blockquote>
<p>buffer切换[上下打开文件切换] 切换文件-下一个文件</p>
<blockquote>
<p>:bn</p>
</blockquote>
<p>切换文件-上一个文件</p>
<blockquote>
<p>:bp</p>
</blockquote>
<p>切换到指定文件</p>
<blockquote>
<p>:b# </p>
</blockquote>
<p>删除#编号buffer</p>
<blockquote>
<p>:bdelete #</p>
</blockquote>
<h5 id="ctag-命令"><a class="header" href="#ctag-命令">CTAG 命令</a></h5>
<blockquote>
<p>Ctrl+] 前往定义</p>
</blockquote>
<blockquote>
<p>Ctrl+t 返回</p>
</blockquote>
<blockquote>
<p>Ctrl+o 前进</p>
</blockquote>
<p>TagList 命令</p>
<pre><code>打开
:Tlist
查看详细
回车
新窗口查看详细
o
查看原型
空格
更新taglist窗口中的tag
u
更改排序方式，在按名字排序和按出现顺序排序间切换
s
taglist窗口放大和缩小，方便查看较长的tag
x
打开一个折叠
zo
将tag折叠起来
zc
打开所有的折叠
zR
将所有tag折叠起来
zM
</code></pre>
<p>WinManager 命令</p>
<pre><code>打开 e 后面跟目录或文件
:e ./
-    返回上级目录
c    切换vim 当前工作目录正在浏览的目录
d    创建目录
D    删除目录或文件
i    切换显示方式
R    文件或目录重命名
s    选择排序方式
x    定制浏览方式, 使用你指定的程序打开该文件
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cssflex"><a class="header" href="#cssflex">cssflex</a></h1>
<pre><code>display: -moz-box;
display: -ms-flexbox;
display: -webkit-box;
display: -webkit-flex;
display: box; 
display: flexbox; 
display: flex;
</code></pre>
<blockquote>
<p>以react-native使用</p>
</blockquote>
<p>容器样式[容器本身也可是上级元素]</p>
<pre><code>flexDirection 内部元素排放方式
row 横向排[注意:子元素宽度无效]
column 竖向排[注意:子元素高度无效]
row-reverse[横反] column-reverse[竖反]
flexWrap 内部元素排放时是否换行[一般为元素过多] nowrap 换行 wrap 不换行 wrap-reverse 底部向上换行
justifyContent 内部元素排放主轴[默认横向]间隔和靠边方式[一般为元素不足] flex-start 开始放,不足尾部留空 flex-end 结尾放,不足开头留空 center 放中间 space-between 两边放,中间间隙大 space-around 两边不放,边间隙跟元素间隙一样大
alignItems 内部元素排放竖向靠边方式[主轴为横向,单排] flex-start 顶部对其 flex-end 底部对其 center 竖向居中 baseline 子元素内文字为标准对其 stretch 子元素高度100%
alignContent 内部元素排放竖向靠边方式[主轴为横向,多排] flex-start 顶部对其 flex-end 底部对其 center 多个竖向居中 space-between 头低放 中间间隙大 space-around 头低不放,间隙同大 stretch 多行元素合成100%
</code></pre>
<p>元素样式</p>
<pre><code>order 元素本身的顺序位置,从小到大排 
flexGrow 放大比例 
flexShrink 缩小比例 
flexBasis 空间有空余时主轴设置为此值 

flex :flex-grow [flex-shrink] [flex-basis] alignSelf 元素本身的位置方式,参考:alignItems</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker"><a class="header" href="#docker">docker</a></h1>
<blockquote>
<p>镜像操作</p>
</blockquote>
<pre><code>#编译 -t 名:tag -f 指定Dockerfile文件
#docker build -t php:1 -f ./docker/yp.Dockerfile ./docker/
#查看镜像
#docker images
#删除镜像
#docker rmi 772c531cd8ea[id]
#从容器中创建镜像
#docker commit -a &quot;test&quot; -m &quot;test&quot; a404c6c174a2 php:1
</code></pre>
<blockquote>
<p>容器操作</p>
</blockquote>
<pre><code>#创建 -v 本地:容器 -d 后台执行 -P 当存在EXPOSE时 -p 端口映射
#docker create -p 80:80 -v /data:/data --name mp php
#运行 停止重启 stop restart
#docker start mp
#查看容器列表 -n 5 限制数量
#docker ps -a
#查看指定容器信息 (镜像可用)
#docker inspect mp
#删除 -v 连带删除数据 -f 强制停止 -l 移除数据连接
#docker rm mp
#从新进入容器/bin/sh
#docker exec -it mp /bin/sh
#创建并运行容器 create &amp;&amp; start
#docker run -d nginx:latest
#以交互方式启动容器 --rm 退出后删除
#docker run --rm -it ubuntu bash
#KILL容器
#docker kill mp
#容器关联 容器内网络相互连通 --link
docker run --rm -it --link mongo -p 9001:9000 php
#环境变量 --env 
docker create -p 8080:8080 --env URLS=&quot;[ { url: 'http://petstore.swagger.io/v2/swagger.json', name: 'TEST1'} ]&quot; --name swagger_dome swaggerapi/swagger-ui
</code></pre>
<blockquote>
<p>本地镜像服务</p>
</blockquote>
<pre><code>#docker run -d -v /registry:/var/lib/registry -p 5000:5000 --restart=always --privileged=true --name registry registry:latest
#客服端修改 /etc/default/docker
#DOCKER_OPTS=&quot;$DOCKER_OPTS --registry-mirror=https://registry.docker-cn.com --insecure-registry=192.168.1.250:5000&quot;
#打指定服务器的TAG后上传
#docker tag ubuntu 192.168.1.250:5000/ub1
#docker push 192.168.1.250:5000/ub1
#其他服务器拉取
#docker pull 192.168.1.250:5000/ub1
</code></pre>
<blockquote>
<p>PHP镜像示例</p>
</blockquote>
<pre><code>FROM alpine:3.8
#指定作者
#MAINTAINER aaa
​
#指定标签
LABEL maintainer=&quot;lonely&quot; version=&quot;1.0&quot;
​
#设置 RUN, CMD 和 ENTRYPOINT 的运行用户
#USER daemo
​
​
#暴露端口
#EXPOSE 80
​
#设置环境变量
#ENV &lt;key&gt;=&lt;value&gt;
​
#拷贝本地文件到指定路径
#ADD &lt;src&gt;... &lt;dest&gt; 支持网络
#COPY &lt;src&gt;... &lt;dest&gt; 只支持本地
​
​
#构件容器时运行
#RUN ls
​
#启动时执行 同时存在cmd 和 ENTRYPOINT 将忽略 ENTRYPOINT 或 cmd 为参数
#ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]
#CMD ls -al
​
#挂载目录 目录自身挂载 无法指定
#VOLUME [&quot;/data1&quot;,&quot;/data2&quot;]
​
#设置工作目录 类似cd
#WORKDIR /path/to/workdir
​
#定义变量
#ARG &lt;name&gt;[=&lt;default value&gt;]
ARG user1=someuser
#功能为容器启动时要运行的命令
​
#容器退出系统发送信号
#STOPSIGNAL INT
​
#子镜像构建时执行
#ONBUILD [INSTRUCTION]
​
#容器健康状况检查命令
#0: success - 表示容器是健康的
#1: unhealthy - 表示容器已经不能工作了
#2: reserved - 保留值
#HEALTHCHECK --interval=5m --timeout=3s CMD curl -f http://localhost/ || exit 1
​
​
ARG timezone
# prod pre test dev
ARG app_env=prod
# default use www-data user
ARG add_user=www-data
​
ENV APP_ENV=${app_env:-&quot;prod&quot;} \
TIMEZONE=${timezone:-&quot;Asia/Shanghai&quot;}
​
### ---------- building ----------
​
RUN set -ex \
&amp;&amp; sed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/' /etc/apk/repositories \
&amp;&amp; apk update \
&amp;&amp; apk add --no-cache \
nginx \
ca-certificates \
curl \
tar \
xz \
libressl \
tzdata \
pcre \
php7 \
php7-bcmath \
php7-curl \
php7-ctype \
php7-dom \
php7-fileinfo \
php7-gettext \
php7-gd \
php7-iconv \
php7-json \
php7-mbstring \
php7-mongodb \
php7-mysqlnd \
php7-openssl \
php7-pdo \
php7-pdo_mysql \
php7-pdo_sqlite \
php7-phar \
php7-posix \
php7-redis \
php7-simplexml \
php7-sockets \
php7-sodium \
php7-session \
php7-sysvshm \
php7-sysvmsg \
php7-sysvsem \
php7-tokenizer \
php7-zip \
php7-zlib \
php7-fpm \
&amp;&amp; apk del --purge *-dev \
&amp;&amp; rm -rf /var/cache/apk/* /tmp/* /usr/share/man /usr/share/php7 \
&amp;&amp; cd /etc/php7 \
&amp;&amp; { \
echo &quot;upload_max_filesize=100M&quot;; \
echo &quot;post_max_size=108M&quot;; \
echo &quot;memory_limit=1024M&quot;; \
echo &quot;date.timezone=${TIMEZONE}&quot;; \
} | tee conf.d/99-overrides.ini \
&amp;&amp; { \
echo &quot;[global]&quot;; \
echo &quot;pid = /var/run/php-fpm.pid&quot;; \
echo &quot;[www]&quot;; \
echo &quot;user = www-data&quot;; \
echo &quot;group = www-data&quot;; \
} | tee php-fpm.d/custom.conf \
&amp;&amp; chown -R www-data:www-data /var/www \
&amp;&amp; { \
echo &quot;#!/bin/sh&quot;; \
echo &quot;nginx -g 'daemon on;'&quot;; \
echo &quot;php-fpm7 -F&quot;; \
} | tee /run.sh \
&amp;&amp; chmod 755 /run.sh \
&amp;&amp; ln -sf /usr/share/zoneinfo/${TIMEZONE} /etc/localtime \
&amp;&amp; echo &quot;${TIMEZONE}&quot; &gt; /etc/timezone \
&amp;&amp; addgroup -g 82 -S ${add_user} \
&amp;&amp; adduser -u 82 -D -S -G ${add_user} ${add_user} \
&amp;&amp; mkdir -p /data \
&amp;&amp; chown -R ${add_user}:${add_user} /data
​
EXPOSE 80
VOLUME [&quot;/var/www&quot;, &quot;/data&quot;]
WORKDIR /var/www
​
CMD /run.sh
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>#es6</p>
<blockquote>
<p>异步函数</p>
</blockquote>
<pre><code>function t(){}
function t1(){}
export {t,t1}
//import {t,t1} from './test';
</code></pre>
<blockquote>
<p>语法糖</p>
</blockquote>
<pre><code>//方式1
var t={
  ['todos/get']() {}
};
//等价于
var t={
  'todos/get':function todosGet(){}//todosGet 函数名
};
//方式2
var t={
  'todosget'() {}
};
//等价于
var t={
  'todosget':function todosget() {}
};
//方式3
var todosget=function(){};
var t={todosget};
//等价于
var t={
  'todosget':function todosget() {}
};
//其他1
const { type1:at1, type2:at2 }={at1:1,at2:1};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react"><a class="header" href="#react">react</a></h1>
<h3 id="属性方法"><a class="header" href="#属性方法">属性方法</a></h3>
<h4 id="属性"><a class="header" href="#属性">属性</a></h4>
<p>a. props [调用模板传数据给代码]只读对象属性[可传对象] 特殊props.children 如果有子元素[数组,当前渲染] 
b. [代码访问内部模板组件] React.createRef(); 
c. state [模板数据变更]单向绑定 初始化:getInitialState 访问:state 修改:setState({}) 会调用render[dom diff]</p>
<h4 id="常用方法"><a class="header" href="#常用方法">常用方法</a></h4>
<p>a. componentDidMount() 组件被装配后立即调用[类似dom ready,一般这里初始化操作] 
b. componentWillUnmount() 组件被卸载后立即调用</p>
<pre><code>class HelloMessage extends React.Component {
    a=1;//es6 属性
    #a=1;//es6  私有属性
    constructor(props={
        liked:false
      }){
    //构造 最先执行
        super(props);
        this.state={
            liked:props.liked
        };
       //这里不能用setState
       //构造[一次]
      }
      componentWillMount(){
        console.log(2);
        //渲染前[一次]
      }
      componentDidMount(){
        console.log(3);
        //渲染后[一次]
      }
      componentWillReceiveProps(){
        //props 变化会调用这里
        //state 变化不会调用
        console.log(4);
      }
      //shouldComponentUpdate(){
        //是否执行更新,优化性能可尝试重写
        //console.log(5);
        //return true;
      //}
      componentWillUpdate(){
        //更新前执行
        console.log(6);
      }
      componentDidUpdate(){
        //更新完执行
        console.log(7);
      }
      componentWillUnmount(){
        //组件卸载调用
        console.log(9);
      }
    handleClick(ref) {
        ref.focus();
        this.setState({liked: !this.state.liked});
        //this.props.obj is object
    }
    render() {
        //渲染其次执行
        //支持数组直接输出
        //var t=[&lt;div/&gt;,&lt;div/&gt;];
        //var b=&lt;div&gt;{t}&lt;div/&gt;;
        //遍历子元素
         //{
              //  React.Children.map(this.props.children, function (child) {
               //   return &lt;li&gt;{child}&lt;/li&gt;;
              //  })
            //  }
            // this.props.children //直接输出子元素
        var text = this.state.liked ? 'like' : 'haven\'t liked';
        let input=React.createRef();
        return &lt;div&gt;
            &lt;span onClick={this.handleClick.bind(this,input)}&gt; Hello{this.props.name}&lt;/span&gt;
            &lt;input type=&quot;text&quot; ref={input} /&gt;
            &lt;p&gt;
                You {text} this
             &lt;/p&gt;
        &lt;/div&gt;;
    }
}
//组件属性 props
HelloMessage.defaultProps = {
  name: 'demo'//默认属性
};
import PropTypes from 'prop-types';
LoginPage.propTypes = {
    user:PropTypes.object,//声明
};
var name='name';
var obj={o:'o'};
ReactDOM.render(
    &lt;HelloMessage name={name} obj={obj}&gt;&lt;/HelloMessage&gt;,
    document.getElementById('example')
);
</code></pre>
<blockquote>
<p>备注</p>
</blockquote>
<p>a. input value 为受控组件 设置后不可修改</p>
<pre><code> &lt;input type=&quot;text&quot; value='' /&gt;
</code></pre>
<p>b. fetch 取代AJAX的网络访问</p>
<pre><code> fetch(this.props.source).then(response=&gt;(console.log(response),response.json())).then(data=&gt;console.log(data));
 //response 是 Response 对象 常用方法 json text 属性 headers
</code></pre>
<p>c. =&gt; 函数</p>
<pre><code> let a = text=&gt;text;//最后一个变量为返回值
 let b = ()=&gt;'ddd';//无参数不可省略()
 let c = (a,b)=&gt;console.log(a,b);//多参数不可省略()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="php笔记"><a class="header" href="#php笔记">PHP笔记</a></h1>
<ul>
<li><a href="php/composer.html">composer</a></li>
<li><a href="php/ext.html">ext</a></li>
<li><a href="php/php7-feature.html">php7-feature</a></li>
<li><a href="php/sort.html">sort</a></li>
<li><a href="php/larvale.html">larvale</a></li>
<li><a href="php/re2candbison.html">re2c&amp;bison</a></li>
<li><a href="php/rabbitmq.html">rabbitmq</a></li>
<li><a href="php/proto.html">proto</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="composer"><a class="header" href="#composer">composer</a></h1>
<ol>
<li>
<p>常用： composer.json</p>
<pre><code>{
   &quot;name&quot;: &quot;lonely/system&quot;,
   &quot;description&quot;: &quot;lonely&quot;,
   &quot;version&quot;: &quot;0.1&quot;,
   &quot;require&quot;: {
       &quot;php&quot;: &quot;&gt;=5.5.0&quot;,
       &quot;ext-yaf&quot;: &quot;&gt;=2.0.0&quot;,
       &quot;monolog/monolog&quot;: &quot;1.19.0&quot;,
       &quot;phpdr.net/php-yaf-doc&quot;:&quot;dev-master&quot;,
       &quot;phpunit/phpunit&quot;:&quot;4.*&quot;,
       &quot;lox/xhprof&quot;:&quot;dev-master&quot;,
       &quot;firephp/firephp-core&quot;:&quot;dev-master&quot;,
       &quot;foolz/profiler&quot;:&quot;dev-master&quot;
   },
   &quot;require-dev&quot;: {
       &quot;php&quot;: &quot;&gt;=5.6.0&quot;
   },
   &quot;license&quot;: &quot;MIT&quot;,
   &quot;autoload&quot;: {
       &quot;psr-4&quot;: {
           &quot;SL\\&quot;: &quot;src/SL&quot;
       }
   },
   &quot;authors&quot;: [
       {
           &quot;name&quot;: &quot;lonely&quot;,
           &quot;email&quot;: &quot;shan.liu@msn.com&quot;
       }
   ],
   &quot;support&quot;: {
       &quot;email&quot;: &quot;shan.liu@msn.com&quot;,
       &quot;irc&quot;: &quot;irc://xxxx&quot;
   }
}
</code></pre>
</li>
<li>
<p>使用本地SVN库</p>
<blockquote>
<ul>
<li>repositories 的 url 中需要有: composer.json</li>
<li>使用 trunk 的版本为: dev-trunk</li>
<li>如果只有 trunk 版本,minimum-stability 设置为: dev</li>
<li>SVN未使用 https ，secure-http 需设置为: false</li>
</ul>
</blockquote>
<pre><code>{
   &quot;name&quot;: &quot;lonely/aaa&quot;,
   &quot;description&quot;: &quot;lonely&quot;,
   &quot;version&quot;: &quot;0.2&quot;,
   &quot;config&quot;: {
       &quot;secure-http&quot;:false,
       &quot;process-timeout&quot;:30
   },
   &quot;repositories&quot;: [
       {
           &quot;type&quot;: &quot;vcs&quot;,
           &quot;url&quot;: &quot;http://127.0.0.1/svnroot/lonely/sl/&quot;,
           &quot;trunk-path&quot;: &quot;trunk&quot;,
           &quot;branches-path&quot;: &quot;branches&quot;,
           &quot;tags-path&quot;: &quot;tags&quot;,
           &quot;svn-cache-credentials&quot;: false
       },
       {
           &quot;type&quot;: &quot;git&quot;,
           &quot;url&quot;: &quot;git://github.com/firephp/firephp-core.git&quot;
       }
   ],
   &quot;http-basic&quot;: {
     &quot;127.0.0.1&quot;: {
         &quot;username&quot;: &quot;username&quot;,
         &quot;password&quot;: &quot;password&quot;
     }
   },
   &quot;require&quot;: {
       &quot;lonely/system&quot;: &quot;dev-trunk&quot;
   },
   &quot;license&quot;: &quot;MIT&quot;,
   &quot;authors&quot;: [
       {
           &quot;name&quot;: &quot;lonely&quot;,
           &quot;email&quot;: &quot;shan.liu@msn.com&quot;
       }
   ],
   &quot;minimum-stability&quot;:&quot;dev&quot;
}
</code></pre>
</li>
<li>
<p>autoload</p>
<blockquote>
<p>files 加载指定文件</p>
</blockquote>
<pre><code>&quot;autoload&quot;: {
   &quot;files&quot;: [&quot;src/MyLibrary/functions.php&quot;]
}
</code></pre>
<blockquote>
<p>classmap 扫描指定目录下以.php或.inc结尾的文件或制定文件文件中的class ，在autoload_classmap.php生成 class 与文件的关系</p>
</blockquote>
<pre><code>{
 &quot;autoload&quot;: {
     &quot;classmap&quot;: [&quot;src/&quot;, &quot;lib/&quot;, &quot;Something.php&quot;]
 }
}
</code></pre>
<blockquote>
<p>PSR-0 按下划线或命名空间加载，参考 Zend 加载</p>
</blockquote>
<pre><code>{
 &quot;autoload&quot;: {
     &quot;psr-0&quot;: {
         &quot;SL\\&quot;: &quot;src/SL&quot;
     }
 }
}
</code></pre>
<blockquote>
<p>PSR-4 按命名空间加载，类似 PSR-0 但不会把下划线转为目录</p>
</blockquote>
<pre><code>{
 &quot;autoload&quot;: {
     &quot;psr-0&quot;: {
         &quot;SL\\&quot;: &quot;src/SL&quot;
     }
 }
}
</code></pre>
<blockquote>
<p>PSR-0 PSR-4 “SL\”: “src/SL” 表示在 src/SL 目录中的PHP文件内容大体如下示例,如A.php内容为:</p>
</blockquote>
<pre><code>&lt;?php
namespace SL;
class A{};
</code></pre>
</li>
<li>
<p>require</p>
<blockquote>
<ul>
<li>require 依赖是扩展，可以通过以下命令得到支持的扩展</li>
</ul>
</blockquote>
<pre><code>composer show --platform
</code></pre>
</li>
<li>
<p>版本控制中去除 vendor 目录</p>
<pre><code>svn propedit svn:ignore .
#添加以下目录和文件
composer.lock
vendor
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ext"><a class="header" href="#ext">ext</a></h1>
<blockquote>
<p>export USE_ZEND_ALLOC=0 #禁用Zend内存管理</p>
<p>export ZEND_DONT_UNLOAD_MODULES=1 #正确显示extension的内存堆栈</p>
<p>valgrind –leak-check=full –show-reachable=yes php test.php #valgrind 检测内存泄漏</p>
</blockquote>
<ol>
<li>
<p>变量操作(常量)</p>
<p>a. 设置变量 ZVAL_*系列函数;例:</p>
<pre><code> zval t;
 ZVAL_STRING(t,&quot;10&quot;,2);
</code></pre>
<p>b. 获取变量 Z_* 系列函数_<br />
<em>c. 获取变量指针 ZP 系列函数</em><br />
<em>d. 获取变量指针的指针 Z</em>_PP 系列函数，例:</p>
<pre><code> Z_STRVAL(t);
 Z_STRLEN(t);
</code></pre>
<p>e. 变量类型转换 convert_to_* 系列函数,例:</p>
<pre><code> convert_to_long_ex(t);
</code></pre>
<p>f. 获取变量类型 Z_TYPE Z_TYPE_P Z_TYPE_PP 可以同 IS_* 系列常量对比,例:</p>
<pre><code> if(Z_TYPE_P(filehandle)!=IS_LONG)
     php_printf(&quot;this is long type!&quot;);
</code></pre>
<p>g. 申请变量的内存</p>
<pre><code> //一般,宏: 
 ALLOC_ZVAL(zv);
 MAKE_STD_ZVAL(zv)
 //用完释放 
 FREE_ZVAL(zv);//等宏
 //释放变量内存 
 zval_dtor(zval);
 zval_ptr_dtor(&amp;zval); 
 FREE_ZVAL(zval);
 //注意:FREE_ZVAL 只释放zval结构体内存,而zval_dtor会释放zval变量及value指针内存
</code></pre>
<p>h. 打印普通变量</p>
<pre><code>  php_printf(&quot;hi function!&quot;);
  //返回输出流,可以使用 PHPWRITE(str, str_len) 继续写
  //打印zval变量 
  php_var_dump(zval **struc, int level TSRMLS_DC);
  //var_dump C实现 在:ext/standard/php_var.h
  zend_print_zval_r(zval *expr, int indent TSRMLS_DC) 
  //print_r C实现 在Zend核心里
</code></pre>
<p>i. 字符串变量生成函数</p>
<pre><code>   spprintf(char **pbuf, size_t max_len, const char *format, ...); 用完释放efree();
</code></pre>
<p>j. 申请内存并复制字符串的副本</p>
<pre><code>   estrdup(&amp;a)；
   estrndup(&amp;a,10);
</code></pre>
<p>k. 变量内存申请:</p>
<pre><code>  emalloc(size);
  efree(ptr);
  //不要用malloc 除非你能明确释放掉
</code></pre>
<p>l. 定义常量:</p>
<pre><code>  REGISTER_*_CONSTANT(name, str, flags)//系列函数 
  flags CONST_* 系列宏
</code></pre>
<p>m. 复制变量</p>
<pre><code>  MAKE_COPY_ZVAL(ppzv, pzv)
  //申请内存并复制
  COPY_PZVAL_TO_ZVAL
  //复制一个zval指向同类型的zval
</code></pre>
</li>
<li>
<p>全局C变量辅助宏:</p>
<pre><code> EG(v);//全局变量 executor_globals 如$_GLOBALS[EG(symbol_table),地址:EG(active_symbol_table)
 PG(v);//核心变量 php_core_globals 如:$_GET $_POST .. PG(http_globals)[TRACK_VARS_*],INI信息
 SG(v);//SAPI变量 请求数据 sapi_globals_struct 如:HTTP原始请求变量 sapi_request_info
 CG(v);//编译变量 compiler_globals 可以得到函数表,类表
 EX(v);//当前执行数据 zend_execute_data 可以获取到当前执行的函数,类,OPCODE等
 OG(v);//输出变量 output_globals
</code></pre>
</li>
<li>
<p>函数,分5类 ZEND_*_FUNCTION 以下为C定义内置函数</p>
<p>函数参数说明 FOR C:</p>
<pre><code> int ht, zval *return_value, zval **return_value_ptr, zval *this_ptr, int return_value_used 
 ht 参数个数,但不能直接使用,该用 ZEND_NUM_ARGS()获取
 return_value 函数返回zval
 return_value_ptr 返回值的指针,但想控制返回值的内容,不是直接返回返回值时候用到,如参数引用实现.
 this_ptr 如果当前方法是一个对象的方法,此值指向该方法指向的对象,不能直接使用,使用 getThis() 函数
 return_value_used 返回值有没有被使用
 例:
 int argc = ZEND_NUM_ARGS();
 char *str=NULL;
 int strlen;
 //次方法用于获取函数参数
 //注意: O 参数须 &amp;object zval 指针 和指明 zend_class_entry * 的指针
 //      s 参数需要 &amp;str char * 指针 和 &amp;strlen int 长度指针
 if (zend_parse_parameters(argc TSRMLS_CC, &quot;s|s&quot;,&amp;str,&amp;strlen) ==FAILURE) {
   return;
 }
 //此方法一般用于类的静态方法,当函数映射类方法的时候.
 //会校验getThis()的类和object是否一个类zend_class_entry
 if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), &quot;Os&quot;, &amp;object, date_ce_date,&amp;str,&amp;strlen) == FAILURE) {
     RETURN_FALSE;
 }
</code></pre>
<p>关于返回</p>
<pre><code> 修改 return_value_ptr 指针指向要用ALLOC_ZVAL_*宏申请内存,
 参考:http://www.walu.cc/phpbook/6.1.md
 返回的宏 RETURN_*系列函数,资源用 ZEND_REGISTER_RESOURCE 
 RETURN_ZVAL(); 返回zval结构
     如果是申请的内存,RETURN_ZVAL(zv, copy, dtor) copy 0 dtor 0
     如果是堆栈内存 RETURN_ZVAL(zv, copy, dtor) copy 1 dtor 0
</code></pre>
</li>
<li>
<p>数组与HASH表 1. zvalue_value 是个union 数组时为 hashtable 2. hashtable 表有很对对应的处理函数:zend_hash系列函数 3. 数组上的HASHTABLE一般不直接操作,通过add__系列函数处理 4. hashtable 内存申请 ALLOC_HASHTABLE 等宏处理,用完释放FREE_HASHTABLE 5. 数组初始化也不要用直接处理hashtable,使用 array_init 处理</p>
</li>
<li>
<p>资源变量 1. 需要使用资源变量须先得到一个资源列表</p>
<p>参数: 1. 请求资源,每次请求会清空此请求的资源列表 2. 永久资源,服务启动后永久保存 3. 显示资源名 4. 内部管理参数,忽略</p>
<pre><code> le_myfile = zend_register_list_destructors_ex(myfile_dtor,NULL,&quot;standard-c-file&quot;, module_number);
 static void myfile_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC){
      FILE *fp = (FILE *) rsrc-&gt;ptr;//转换指定类型,方便以后操作
      fclose(fp);
 }
</code></pre>
<ol>
<li>
<p>把资源注册进资源列表,并设置return_value</p>
<pre><code>int r=ZEND_REGISTER_RESOURCE(return_value, fp, le_myfile);
</code></pre>
</li>
<li>
<p>查询资源 filehandle 为资源zval</p>
<pre><code>ZEND_FETCH_RESOURCE(fp, FILE *, &amp;filehandle, -1, &quot;standard-c-file&quot;,le_myfile);
if (fp == NULL){
RETURN_FALSE;
}
</code></pre>
</li>
<li>
<p>删除资源 filehandle 为资源zval</p>
<pre><code>if (zend_list_delete(Z_RESVAL_P(filehandle)) == FAILURE) {
 RETURN_FALSE;
}
</code></pre>
</li>
</ol>
</li>
<li>
<p>全局函数</p>
<pre><code>zend_function_entry test_functions[] =
{
   //参数 : 函数名 
   ZEND_FE(myecho, NULL)
   ZEND_FE_END
};
//注册到模块中
zend_module_entry php_test_module_entry = {
#if ZEND_MODULE_API_NO &gt;= 20010901
   STANDARD_MODULE_HEADER,
#endif
   &quot;my test ext&quot;,//模块名
   test_functions,//函数列表
   NULL,
   NULL,
   NULL,
   NULL,
   PHP_MINFO(php_test),//模块介绍
#if ZEND_MODULE_API_NO &gt;= 20010901
   &quot;1.6.0&quot;, //版本
#endif
   STANDARD_MODULE_PROPERTIES
};
</code></pre>
<p>//函数实现,参考 3.函数部分</p>
<pre><code> PHP_FUNCTION(myecho){}
</code></pre>
<p>用户函数调用: 参数: function_table 函数表,全局从&amp;CG(function_table)得到 对象,如果该函数是对象的方法,没有传NULL 函数名 返回值存储 zval指针, 参数数量 参数数组</p>
<pre><code> call_user_function(HashTable *function_table, zval **object_pp, zval *function_name, zval *retval_ptr, zend_uint param_count, zval *params[] TSRMLS_DC);
</code></pre>
</li>
<li>
<p>类的实现</p>
<p>结构:zend_class_entry 分两种 ZEND_INTERNAL_CLASS 和 ZEND_USER_CLASS</p>
<pre><code> //访问权限控制:ZEND_ACC_*系列宏
 //类方法定义
 //参数:类名 方法名 
 ZEND_METHOD( myclass , public_method )
 {
     //获取参数方法,参考:3.函数 部分
     if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), &quot;s&quot;, &amp;str,&amp;strlen) == FAILURE) {
         RETURN_FALSE;
     }
     php_printf(&quot;hi function!&quot;);
 }
 //注册到函数列表
 static zend_function_entry myclass_method[]={
     //参数:类名 方法名 静态方法加 ZEND_ACC_STATIC
     ZEND_ME(myclass,    public_method,    NULL,    ZEND_ACC_PUBLIC)
     {NULL,NULL,NULL}
 };
 zend_class_entry ce;
 zend_class_entry *myclass_ce;
 //参数:初始结构 类名 方法列表
 INIT_CLASS_ENTRY(ce,&quot;myclass&quot;,myclass_method);
 //此方法会根据ce拷贝生成一个zend_class_entry并挂载到类列表中
 zend_register_internal_class(&amp;ce TSRMLS_CC);
 //添加类的属性
 //参数:类指针 属性名 属性名长度 属性访问权限 : zend_declare_property_* 系列函数
 zend_declare_property_null(myclass_ce, &quot;public_var&quot;, strlen(&quot;public_var&quot;), ZEND_ACC_PUBLIC TSRMLS_CC);
 //
 //定义类常量:
 //参数:类指针 属性名 属性名长度 属性访问权限 : zend_declare_class_constant* 系列函数
 zend_declare_class_constant_null(myclass_ce, &quot;aaa&quot;, 3 TSRMLS_DC);
 //
 //读取类静态属性
     ZEND_API zval *zend_read_static_property(
         zend_class_entry *scope, 
         char *name, 
         int name_length, 
         //属性不存在是否抛出 notice
         zend_bool silent TSRMLS_DC
     );
 更新类静态属性
     ZEND_API int zend_update_static_property(
         zend_class_entry *scope, 
         char *name, 
         int name_length, 
         zval *value TSRMLS_DC
     );
 其他封装的快捷函数 zend_update_static_property_*
</code></pre>
</li>
<li>
<p>接口 结构也是: zend_class_entry</p>
<pre><code> static zend_function_entry i_myinterface_method[]={
     //注意这里的null指的是arg_info,具体可以参考:参数 arg_info 的定义
     ZEND_ABSTRACT_ME(i_myinterface, hello, NULL) 
     ZEND_FE_END
 };
 //定义及初始化
 zend_class_entry ce;
 INIT_CLASS_ENTRY(ce, &quot;i_myinterface&quot;, i_myinterface_method);
 i_myinterface_ce = zend_register_internal_interface(&amp;ce TSRMLS_CC);
</code></pre>
</li>
<li>
<p>继承及接口实现 1.实现接口: 写完类,接口后添加: 参数: 类指针 ,实现接口数量,接口指针…</p>
<pre><code>     zend_class_implements(class_ce TSRMLS_CC,1,myinterface_ce);
</code></pre>
<p>2.实现继承: 注册类时候使用: zend_register_internal_class_ex 参数: 类指针 父类指针 父类名</p>
<pre><code>     myclass_ce = zend_register_internal_class_ex(&amp;ce,parent_class_ce,&quot;parent_class&quot; TSRMLS_CC);
</code></pre>
</li>
<li>
<p>对象 zend_object_value</p>
<p>结构:</p>
<pre><code>typedef struct _zend_object_value {
    //unsigned int类型，EG(objects_store).object_buckets的索引
    zend_object_handle handle;
    zend_object_handlers *handlers;
} zend_object_value;
</code></pre>
<p>创建对象:</p>
<pre><code>zval *obj;
MAKE_STD_ZVAL(obj);
object_init_ex(obj, zend_class_entry 类名 );
//object_init(obj) 空对象
</code></pre>
<p>读取属性:</p>
<pre><code>ZEND_API zval *zend_read_property(
    zend_class_entry *scope, 
    zval *object, 
    char *name, 
    int name_length, 
    //属性不存在是否抛出 notice
    zend_bool silent TSRMLS_DC
);
</code></pre>
<p>更新属性:</p>
<pre><code>ZEND_API int zend_update_static_property(
    zend_class_entry *scope, 
    char *name, 
    int name_length, 
    zval *value TSRMLS_DC
);
</code></pre>
<p>其他封装的快捷函数 zend_update_property_* 调用方法:</p>
<pre><code>ZEND_API zval* zend_call_method(zval **object_pp, zend_class_entry *obj_ce, zend_function **fn_proxy, const char *function_name, int function_name_len, zval **retval_ptr_ptr, int param_count, zval* arg1, zval* arg2 TSRMLS_DC);
zend_call_method_with_0_params(obj, obj_ce, fn_proxy, function_name, retval)
zend_call_method_with_1_params(&amp;this_zval,myclass_ce,NULL,&quot;hello&quot;,NULL);
</code></pre>
</li>
<li>
<p>常用结构及宏解释:</p>
<pre><code>PHP_FN(name) 函数名生成
PHP_MN(name) 方法名生成
ZEND_NAMED_FUNCTION(name) 生成指定名的函数 一般用
PHP_FUNCTION(name) 函数声明
ZEND_METHOD(classname, name) 类方法声明
//
zend_function_entry    数组用于声明模块或类的成员函数情况
生成zend_function_entry的元素配套宏:
    //注册全局的函数
    //参数:函数名 参数
    PHP_FE(name, arg_info) 
    //注册类的函数
    //参数:类名 方法名 参数 访问权限控制
    PHP_ME(classname, name, arg_info, flags) 
    //映射一个函数为类的方法
    //参数:方法名 函数名 参数 访问权限控制 
    //用此宏须在函数体内进行类校验,zend_parse_method_parameters 
    //调用时会把当前对象作为第一个参数传递给函数
    PHP_ME_MAPPING(name, func_name, arg_types, flags)
    //注册类的抽象函数,类和接口都用这个
    //参数:类名 方法名 参数
    PHP_ABSTRACT_ME(classname, name, arg_info) 
    //结束标记
    PHP_FE_END
</code></pre>
</li>
<li>
<p>参数 arg_info 的定义</p>
<pre><code>//一般情况下不需要定义参数,除非你希望PHP般你检查参数正确性,比如接口方法
//生成arg_info的宏,以arg_say_hello为例:
//参数:zend_arg_info 名,参数至少前N个
ZEND_BEGIN_ARG_INFO(arg_say_hello, 0)
//参数:是否设置为引用,参数名
//ZEND_ARG_* 系列函数还可以声明对象等
ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO()
//其他介绍
//name    参数名称
//name_len    参数名称字符串长度
//class_name    当参数类型为类时，指定类名称
//class_name_len    类名称字符串长度
//array_type_hint    标识参数类型是否为数组
//allow_null    是否允许设置为空
//pass_by_ref    是否设置为引用，即使用&amp;操作符
//return_reference    标识函数将重写return_value_ptr，后面介绍函数返回值时再做介绍
//required_num_args    设置函数被调用时，传递参数至少为前N个，当设置为-1时，必须传递所有参数
</code></pre>
</li>
<li>
<p>目录结构</p>
<pre><code>ext/ 扩展
ext/standard PHP内置函数
Zend/ PHP核心
Zend/zend_builtin_functions.c 核心函数 还有常用的辅助函数
sapi/ sapi接口实现
main/ 对外编写接口
</code></pre>
</li>
<li>
<p>流程及扩展备注</p>
<pre><code>zend_module_entry php_test_module_entry = {
    STANDARD_MODULE_HEADER,
    &quot;my test ext&quot;,                /* 模块名称 */
    test_functions,                /* 模块函数 */
    PHP_MINIT(test),            /* 模块启动 */
    PHP_MSHUTDOWN(test),        /* 模块关闭 */
    PHP_RINIT(test),            /* 请求开始 */
    PHP_RSHUTDOWN(test),        /* 请求完成 */
    PHP_MINFO(php_test),        /* 模块信息 */
    &quot;1.6.0&quot;,                     /* 模块版本 */
    //还可以增加全局变量注册部分,参考:16.全局变量
    STANDARD_MODULE_PROPERTIES
};
ZEND_GET_MODULE(php_test);
PHP_MINIT_FUNCTION(test)
{
    //此阶段注册类等
    //注册INI
    //REGISTER_INI_ENTRIES();
    return SUCCESS;
}
PHP_RINIT_FUNCTION(test){
    return SUCCESS;
}
PHP_RSHUTDOWN_FUNCTION(test){
    return SUCCESS;
}
PHP_MSHUTDOWN_FUNCTION(test)
{
    UNREGISTER_INI_ENTRIES();
    return SUCCESS;
}
</code></pre>
</li>
<li>
<p>配置设置与获取</p>
<pre><code>PHP_INI_BEGIN()
    PHP_INI_ENTRY(&quot;myini&quot;,&quot;bbb&quot;,PHP_INI_ALL, NULL)
PHP_INI_END()
//一般在 PHP_MINIT_FUNCTION 注册
PHP_MINIT_FUNCTION(test)
{
    //***
    REGISTER_INI_ENTRIES();
    //***
}
//获取配置:
///INI_* 系列宏
</code></pre>
</li>
<li>
<p>线程安全的全局变量,并定义获取方法,类似于:EG(v) PG(v) SG(v) 等实现</p>
<pre><code>//test 一般为模块名,也可以用其他,用模块名号记忆
//注意:全局变量不跟随请求,请求完成不会重置.
ZEND_BEGIN_MODULE_GLOBALS(test)
    int flags;
ZEND_END_MODULE_GLOBALS(test)
#ifdef ZTS
# define YOURGET(v) TSRMG(test_globals_id, zend_test_globals *, v)
#else
# define YOURGET(v) (test_globals.v)
#endif
//以上为声明部分
//
//以下为:初始化及注册到PHP内核中
ZEND_DECLARE_MODULE_GLOBALS(test);
//全局可用
//ZEND_EXTERN_MODULE_GLOBALS(test);
zend_module_entry php_test_module_entry = {
    STANDARD_MODULE_HEADER,
    &quot;my test ext&quot;,
    test_functions,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NO_VERSION_YET,//以下为开启全局变量时增加
    PHP_MODULE_GLOBALS(test),//作用:注册到全局变量中
    PHP_GINIT(test),//全局变量初始化时调用函数,一般为启动PHP时,可为NULL
    PHP_GSHUTDOWN(test),//全局变量销毁时调用函数,一般为关闭PHP时,可为NULL
    NULL,
    STANDARD_MODULE_PROPERTIES_EX //注意:多个EX
};
//全局变量注册的回调函数 宏
static PHP_GINIT_FUNCTION(test)
{
    test_globals-&gt;flags = 0;
}
static PHP_GSHUTDOWN_FUNCTION(test)
{
    //其他操作,如释放申请的内存等
}
</code></pre>
</li>
<li>
<p>gdb调试扩展</p>
<p>PHP编译的时候加上 -–enable-debug 参数 修改config.m4</p>
<pre><code>if test -z &quot;$PHP_DEBUG&quot; ; then
   AC_ARG_ENABLE(debug,
           [--enable-debug compile with debugging system],
           [PHP_DEBUG=$enableval],[PHP_DEBUG=no]
   )
fi
</code></pre>
<p>./configure 的时候加入 –enable-debug</p>
<p>设置 core 的大小</p>
<pre><code>ulimit -c unlimited
</code></pre>
<p>//以下假设php路径在系统的/usr/bin或/usr/local/bin中</p>
<pre><code>gdb php -c core[core为生成的core文件]
</code></pre>
<p>常用调试命令:</p>
<pre><code>r 运行
b 设置断点
set args 设置参数
n 运行下一步
c 继续运行
p 打印
watch 当变量修改断点
list  查看代码
layout src 显示源码
layout asm 显示汇编
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="php7-feature"><a class="header" href="#php7-feature">php7-feature</a></h1>
<ol>
<li>
<p>命名空间简化</p>
<pre><code>use a\b\{a,b};
</code></pre>
</li>
<li>
<p>?? 语法</p>
<pre><code>$username = $_GET['user'] ?? $_POST['user'] ?? 'nobody';
//不存在用下一个值
</code></pre>
</li>
<li>
<p>函数强类型</p>
<pre><code>function foobar(float $abc): bool {
 return $abc+1;
}
echo foobar(0.5);
</code></pre>
</li>
<li>
<p>new类直接使用</p>
<pre><code>class s {public $x = 1;}
(new s())-&gt;x;
</code></pre>
</li>
<li>
<p>闭包调用类调用</p>
<pre><code>class S{private $x=10;};
$getX = function() {return $this-&gt;x;};
echo $getX-&gt;call(new s);
</code></pre>
</li>
<li>
<p>同类型不定参数</p>
<pre><code>function sumOfInts(int ...$ints)
{
 return array_sum($ints);
}
var_dump(sumOfInts(2, '3', 4.1));
</code></pre>
</li>
<li>
<p>生成器yield</p>
<pre><code>function xrange() {
 echo &quot;aa&quot;;
 $a=yield 1;
 $b=yield 2;
}
$x=xrange();
//调用时候才运行xrange内容 $x 为Generator
//调用1
foreach ($x as $num) {
 echo $num, &quot;\n&quot;;
}
//调用2
$x-&gt;send(&quot;a&quot;);
$x-&gt;send(&quot;b&quot;);
</code></pre>
</li>
<li>
<p>匿名类</p>
<pre><code>echo (new class{public $a=10;})-&gt;a;
</code></pre>
</li>
<li>
<p>数组常量支持</p>
<pre><code>define(&quot;A&quot;, [&quot;C&quot;=&gt;&quot;a&quot;,&quot;bb&quot;]);
echo A['C'];
</code></pre>
</li>
<li>
<p>Trait 代码片段</p>
<pre><code>trait trait1 {
public function a() { echo &quot;1a&quot;;}
public function b() { echo &quot;1b&quot;;}
}
trait trait2 {
public function a() { echo &quot;2a&quot;; }
}
trait trait3 {
use trait1, trait2 {
    trait2::a insteadof trait1;
}
}
class cls1{
use trait1, trait2 {
    //用 trait2::a 代替 trait1的a
    trait2::a insteadof trait1;
    //方法重命名
    trait1::b as c;
}
}
class cls2 {
use trait1;
}
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sort"><a class="header" href="#sort">sort</a></h1>
<pre><code class="language-php">&lt;?php
//版本1
function q2sort(&amp;$arr){
    if(count($arr)&gt;1){
        $k=$arr[0];
        $x=array();
        $y=array();
        $_size=count($arr);
        for($i=1;$i&lt;$_size;$i++){
            if($arr[$i]&lt;=$k){
                $x[]=$arr[$i];
            }elseif($arr[$i]&gt;$k){
                $y[]=$arr[$i];
            }
        }
        $x=q2sort($x);
        $y=q2sort($y);
        return array_merge($x,array($k),$y);
    }else{
        return$arr;
    }
}
$a=array(13,22,12,17,32,23,12,25,22,32,12);
$a=q2sort($a);
print_r($a);
//----------------------------------------------------------------------------
//版本二
function start_move($c,&amp;$a,$start,$end){
    while(true){
        if($start==$end){$a[$start]=$c;break;}
        if($a[$start]&gt;$c){
            $a[$end]=$a[$start];
            return end_move($c,$a,$end-1,$start);
        }else{ $start++;}
    }
    return $start;
}
function end_move($c,&amp;$a,$end,$start){
    while(true){
        if($start==$end){$a[$start]=$c;break;}
        if($a[$end]&lt;$c){
            $a[$start]=$a[$end];
            return start_move($c,$a,$start+1,$end);
        }else{ $end--;}
    }
    return $start;
}
function q1sort(&amp;$a,$start,$end){
    if($start&gt;=$end)return ;
    $c=end_move($a[$start],$a,$end,$start);
    q1sort($a,0,$c-1);
    q1sort($a,$c+1,$end);
}
$a=array(13,22,12,17,32,23,12,25,22,32,12);
q1sort($a,0,count($a)-1);
print_r($a);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="larvale"><a class="header" href="#larvale">larvale</a></h1>
<pre><code>注册路径
添加 APP对象到DI 包详细对象(PackageManifest)到DI
注册服务提供:事件 日志 路由对象到DI
设置常用别名
添加 HTTP 控制台 异常处理 到DI
创建HTTP对象运行:(中途有事件派发,Application属性方式注册回调函数调用省略)
    使用 APP对象[bootstrapWith]运行 bootstrappers
        LoadEnvironmentVariables 基本服务器环境参数
        LoadConfiguration 把环境参数转为 config 对象注册DI
        HandleExceptions 未处理异常处理注册
        RegisterFacades 快捷类调用注册 为Application的注册对象
        RegisterProviders 进行Application[registerConfiguredProviders]配置的服务器提供者注册providers
        BootProviders 运行已注册的服务提供者的boot方法
    执行运行回调 middleware
        $next 运行前调用
            注册request到DI
            派发路由
            根据当前路由查找路由组的 middlewareGroups 和\\\
            路由中 $routeMiddleware(对回调命名) 和 如果存在控制器[middleware()]中getMiddleware() 注册的回调或路由中调用middleware()
            并按 middlewarePriority 排序后进行,并在$next 运行前调用
            运行路由注册回调函数 并将返回包裹成 Response 对象
            完成$next 运行后回调运行
        完成$next 运行后回调运行
    发送Response到客户端
    执行上述运行回调中的 terminate(如果存在) 和 Application-&gt;terminatingCallbacks
</code></pre>
<p>执行回调: handle($request, Closure $next, …$guards); $request 请求对象 $next($request); 运行后结果对象 $guards 注册时附带数据 如[throttle:60,1]</p>
<p>快捷调用接口: extends Facade getFacadeAccessor(); 返回为 对应注册的别名</p>
<p>服务提供者: provides();//延时注册:依赖defer when();//某事件注册 ServiceProvider register() bindings=[]==singletons=[] =[‘key’,function(){}]; boot [已运行后注册]</p>
<p>依赖管理器:DI[Application] 设置 singleton(); instance(); bindIf(); bind(); 获取 makeWith(); factory(); make(); get();</p>
<p>路由注册 name 在 route() 函数中使用 middleware() 参数可以是类名 回调函数 或在 Kernel-&gt;$routeMiddleware 的key get()post()…等 为路径和回调处理 可以是控制器 Route::name(“index”) -&gt;middleware(\App\Http\Middleware\RedirectIfAuthenticated::class) -&gt;get(‘/’,“MyController@index”);</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="re2cbison"><a class="header" href="#re2cbison">re2c&amp;bison</a></h1>
<p>BNF:</p>
<p>非终结符: 终结符|非终结符</p>
<p>流程</p>
<p>yyparse(bison 入口) -&gt;(内部) yylex -&gt;(内部) scan(re2c 正则分词,返回token) -&gt; 语法分析 -&gt;构建ast</p>
<p>添加PHP语法:</p>
<pre><code>| variable '=' '&amp;' variable { \$$ = zend\_ast\_create(ZEND\_AST\_ASSIGN\_REF, $1, $4); }
</code></pre>
<p>//下面添加 </p>
<pre><code>| variable '=' '?' expr { \$$ = zend\_ast\_create(ZEND\_AST\_ASSIGN, $1, zend\_ast\_create(ZEND\_AST\_COALESCE, $1, $4)); }
</code></pre>
<p>支持 $a=?1111; 当$a 未定义时赋值</p>
<div style="break-before: page; page-break-before: always;"></div><p>#rabbitmq</p>
<p>composer</p>
<pre><code>&quot;php-amqplib/php-amqplib&quot;: &quot;&gt;=2.6.1&quot;,
</code></pre>
<p>使用注释</p>
<pre><code>&lt;?php
//流程
//发送消息 -&gt; 交换器[未指定默认交换器,按队列名(派发到指定队列)] -[按规则,直接,主题,消息头,广播]-&gt; 队列[临时队列] -&gt; 处理消息
​
//延时消息
//发送过期消息到指定队列 队列配置超时转发 -&gt; 超时消息进入超时处理队列 -&gt; 处理消息
//'x-dead-letter-exchange'=&gt;'dead-queue',
//'x-dead-letter-routing-key'=&gt;'xxx'
​
//消息体: AMQPMessage
// 'content_type' =&gt; 'shortstr',
// 'content_encoding' =&gt; 'shortstr',
// 'application_headers' =&gt; 'table_object',
// 'delivery_mode' =&gt; 'octet',//是否持久化
// 'priority' =&gt; 'octet',//优先级
// 'correlation_id' =&gt; 'shortstr',//RPC回复标识请求ID
// 'reply_to' =&gt; 'shortstr',//RPC回复临时队列名
// 'expiration' =&gt; 'shortstr',
// 'message_id' =&gt; 'shortstr',
// 'timestamp' =&gt; 'timestamp',
// 'type' =&gt; 'shortstr',
// 'user_id' =&gt; 'shortstr',
// 'app_id' =&gt; 'shortstr',
// 'cluster_id' =&gt; 'shortstr',
​
​
//AMQPChannel 推送 
function basic_publish(
    $msg,//消息内容
    $exchange = '',//交换机名
    $routing_key = '',//路由字符
    $mandatory = false,//如果exchange通过routeKey无法符合queue，调用basic.return方法将消息返还给生产者；当mandatory设为false时，将消息扔掉
    $immediate = false,//如果exchange在将消息route到queue(s)时发现对应的queue上没有消费者，那么这条消息不会放入队列中。当与消息routeKey关联的所有queue(一个或多个)都没有消费者时，该消息会通过basic.return方法返还给生产者
    $ticket = null
){}
//AMQPChannel 交换机
function exchange_declare(
        $exchange,//交换机名,存在跳过,不存在建立,存在且配置不同出错
        $type,//规则direct 按路由字符相等 topic 按路由字符匹配 fanout 全体广播  headers
        $passive = false,//设为true，如果该队列已存在，则会返回true；如果不存在，则会返回Error，但是不会创建新的队列
        $durable = false,//交换机是否持久化
        $auto_delete = true,//是否自动删除,链接断开时删除,临时交换机使用
        $internal = false,//这里Internal设置为false，否则将无法接受dead letter，true表示这个exchange不可以被client用来推送消息
        $nowait = false,
        $arguments = null,
        $ticket = null
){}
//AMQPChannel 负载设置
function basic_qos(
    $prefetch_size, 
    $prefetch_count,//每次负载数量 
    $a_global
){}
//AMQPChannel 队列获取
function queue_declare(
        $queue = '',//队列名,为空创建临时队列
        $passive = false,//设为true，如果该队列已存在，则会返回true；如果不存在，则会返回Error，但是不会创建新的队列
        $durable = false,//是否持久化
        $exclusive = false,//创建一个只有自己可见的队列，即不允许其它用户访问
        $auto_delete = true,//是否自动删除,临时队列使用
        $nowait = false,
        $arguments = null,
        $ticket = null
) {}
//AMQPChannel 绑定交换机和队列
function queue_bind(
        $queue, //路由名
        $exchange, //交换机名
        $routing_key = '',//路由字符 
        $nowait = false, 
        $arguments = null, 
        $ticket = null
){}
//AMQPChannel 队列监听
function basic_consume(
        $queue = '',//队列名
        $consumer_tag = '',//用户标识符，在当前通道中有效。
        $no_local = false,
        $no_ack = false,//是否自动确认
        $exclusive = false,//独占指定队列,不可被其他监听
        $nowait = false,
        $callback = null,//回调函数
        $ticket = null,
        $arguments = array()
) {}
//回调函数
$callback = function($msg){
  //$msg is AMQPMessage
  echo &quot; [x] Received &quot;, $msg-&gt;body, &quot;\n&quot;;
  //确认消息消费
  $msg-&gt;delivery_info['channel']-&gt;basic_ack($msg-&gt;delivery_info['delivery_tag']);
  //把消息重新回到队列,小心死循环...
 // $msg-&gt;delivery_info['channel']-&gt;basic_nack($msg-&gt;delivery_info['delivery_tag']);
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protobuf"><a class="header" href="#protobuf">protobuf</a></h1>
<p>//composer.json</p>
<pre><code>{
    &quot;autoload&quot;:{
        &quot;psr-4&quot;: {
            &quot;&quot; : &quot;src/proto/&quot;
        }
    }
}
</code></pre>
<pre><code class="language-php">$user=new Foo\User();
//联合体 只可能存在一个
$user-&gt;setOne1(1);
$user-&gt;setOne2(2);
$user-&gt;setUserId(100);
$user-&gt;setUserHeight(1.1);
$user-&gt;setUserMoney(11);
$user-&gt;setUserName(&quot;namne&quot;);
$user-&gt;setUserType(Foo\UserType::HIG);
$ui=new Foo\UserItem();
$ui-&gt;setItemId(1);
$ui-&gt;setItemName(&quot;item&quot;);
$ui1=new Foo\UserItem();
$ui1-&gt;setItemId(1);
$ui1-&gt;setItemName(&quot;item&quot;);
$uis=array($ui,$ui1);
$user-&gt;setUserItems($uis);
$arr=array(1=&gt;1111);
$user-&gt;setAttr($arr);
//生成出二进制字符
$k=($user-&gt;serializeToString());
//生成出JSON字符
// echo $user-&gt;serializeToJsonString();
// exit;
//还原为对象
$buser=new Foo\User();
$buser-&gt;mergeFromString($k);
var_dump($buser-&gt;getOne1());
var_dump($buser-&gt;getOne2());
var_dump(iterator_to_array($buser-&gt;getAttr()));
var_dump($buser-&gt;getUserHeight());
var_dump($buser-&gt;getUserId());
var_dump(iterator_to_array($buser-&gt;getUserItems()));
var_dump($buser-&gt;getUserMoney());
var_dump($buser-&gt;getUserName());
var_dump($buser-&gt;getUserType());
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="book.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
